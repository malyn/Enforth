{:token :abort}

{:token :abs}

;; ACCEPT [CORE] 6.1.0695 ( c-addr +n1 -- +n2 )
;;
;; Receive a string of at most +n1 characters.  An ambiguous condition
;; exists if +n1 is zero or greater than 32,767.  Display graphic
;; characters as they are received.  A program that depends on the
;; presence or absence of non-graphic characters in the string has an
;; environmental dependency.  The editing functions, if any, that the
;; system performs in order to construct the string are
;; implementation-defined.
;;
;; Input terminates when an implementation-defined line terminator is
;; received.  When input terminates, nothing is appended to the string,
;; and the display is maintained in an implementation-defined way.
;;
;; +n2 is the length of the string stored at c-addr.
;;
;; TODO Deal with backspace.
{:token :accept
 :args [[:c-addr :n1] [:n2]]
 :source ": ACCEPT ( c-addr max -- n)
            OVER + OVER ( ca-start ca-end ca-dest)
            BEGIN  KEY  DUP 10 <> WHILE
              DUP 2OVER ( cas cae cad c c cae cad) <> IF
                EMIT OVER C! ( cas cae cad) 1+
              ELSE
                ( cas cae cad c c) 2DROP
              THEN
            REPEAT
            ( ca-start ca-end ca-dest c) DROP NIP SWAP - ;"
 :pfa [:over :plus :over
       :key :dup :charlit 10 :notequals :zbranch 15
         :dup :twoover :notequals :zbranch 7
           :emit :over :cstore :oneplus :branch 2
           :twodrop
         :branch -20
       :drop :nip :swap :minus
       :exit]}

{:token :align}

{:token :allot}

{:token :and}

{:token :backslash :name "\\"}

{:token :base
 :args [[] [:aaddr]]
 :pfa [:vmaddrlit "offsetof(EnforthVM, base)" :exit]}

{:token :bl
 :args [[] [:c]]
 :source ": BL ( --)  $20 ;"
 :pfa [:charlit "' '" :exit]}

{:token :ccomma :name "C,"}

{:token :cfetch :name "C@"}

;; : [CORE] 6.1.0450 "colon" ( C: "<spaces>name" -- colon-sys )
;;
;; Skip leading space delimiters.  Parse name delimited by a space.
;; Create a definition for name, called a "colon definition".  Enter
;; compilation state and start the current definition, producing
;; colon-sys.  Append the initiation semantics given below to the
;; current definition.
;;
;; The execution semantics of name will be determined by the words
;; compiled into the body of the definition.  The current definition
;; shall not be findable in the dictionary until it is ended (or until
;; the execution of DOES> in some systems).
;;
;; Initiation: ( i*x -- i*x ) ( R: -- nest-sys )
;;   Save implementation-dependent information nest-sys about the
;;   calling definition.  The stack effects i*x represent arguments to
;;   name.
;;
;; name Execution: ( i*x -- j*x )
;;   Execute the definition name.  The stack effects i*x and j*x
;;   represent arguments to and results from name, respectively.
{:token :colon
 :name ":"
 :args [[] []]
 :source ": LFA>CFA ( addr -- addr)  1+ 1+ ;
          : : ( \"<spaces>name\" -- )
            CREATE  HIDE  CFADOCOLON LATEST @ LFA>CFA C! ;"
 :pfa [:create :hide :charlit "kDefTypeCOLON" :latest :fetch
       ; LFA>CFA
         :oneplus :oneplus
       :cstore :rtbracket
       :exit]}

{:token :comma :name ","}

{:token :compilecomma
 :name "COMPILE,"
 :args [[:xt] []]
 :source ": CFA>TOKEN ( def-type -- token)  $F0 OR ;
          : COMPILE, ( xt --)
            DUP TOKEN? IF C, EXIT THEN
            DUP >CFA C@ CFA>[TOKEN] C,  >BODY 'DICT - W, ;"
 :pfa [:dup :tokenq :zbranch 3
         :ccomma :exit
       :dup :tocfa :cfetch
       ; CFA>[TOKEN]
         :charlit 0xf0 :or
       :ccomma :tobody
       ; TICKDICT
         :vmaddrlit "offsetof(EnforthVM, dictionary)" :fetch
       :minus :wcomma
       :exit]}

{:token :count}

{:token :cstore :name "C!"}

{:token :cr
 :args [[] []]
 :source ": CR ( --)  $0A EMIT ;"
 :pfa [:charlit 0x0a :emit :exit]}

{:token :create
 :args [[] []]
 :source ": TERMINATE-NAME ( ca u -- ca u)  2DUP 1- +  $80 SWAP C+! ;
          : S, ( ca u --)  TUCK  HERE SWAP MOVE  ALLOT ;
          : NAME, ( ca u --)  TERMINATE-NAME S, ;
          : >LATEST-OFFSET ( addr -- u)  LATEST @ DUP IF - ELSE NIP THEN ;
          : CREATE ( \"<spaces>name\" -- )
            BL PARSE-WORD DUP 0= IF ABORT THEN ( ca u)
            HERE  DUP >LATEST-OFFSET W,  LATEST ! ( ca u)
            CFADOCREATE C, ( ca u)  NAME,  ALIGN ;"
 :pfa [:bl :parseword :dup :zeroequals :zbranch 2 :abort
       :here :dup
       ; >LATEST-OFFSET
         :latest :fetch :dup :zbranch 4
           :minus :branch 2
           :nip
       :wcomma :latest :store
       :charlit "kDefTypeCREATE" :ccomma
       ; NAME
         ; TERMINATE-NAME
           :twodup :oneminus :plus :charlit 0x80 :swap :cplusstore
         ; S,
           :tuck :here :swap :move :allot
       :align
       :exit]}

{:token :depth}

{:token :dot
 :name "."
 :args [[:n] []]
 :source "BASE @ 10 <>  IF U. EXIT THEN
         DUP ABS 0 <# #S ROT SIGN #> TYPE SPACE ;"
 :pfa [:base :fetch :charlit 10 :notequals :zbranch 3 :udot :exit
       :dup :abs :zero :lessnumsign :numsigns :rot :sign,
       :numsigngrtr :type :space
       :exit]}

{:token :dup :args [[:x] [:x :x]]}

{:token :drop :args [[:x1 :x2] [:x1]]}

{:token :emit}

{:token :equals :name "="}

{:token :false}

{:token :fetch :name "@"}

;; EXECUTE [CORE] 6.1.1370 ( i*x xt -- j*x )
;;
;; Remove xt from the stack and perform the semantics identified by it.
;; Other stack effects are due to the word EXECUTEd.
{:token :execute
 :args [[:xt] []]
 :source ": (EXECUTE) ( i*x token w -- j*x) ... ;
          : EXECUTE ( i*x xt -- j*x)
            DUP TOKEN? IF 0
            ELSE DUP >CFA C@ CFA>TOKEN  SWAP >BODY THEN
            (EXECUTE) ;"
 :pfa [:dup :tokenq :zbranch 4
         :zero :branch 9
       :dup :tocfa :cfetch
       ; CFA>TOKEN
         :charlit 0xe0 :or
       :swap :tobody
       :pexecute
       :exit]}

{:token :greaterthan :name ">"}

{:token :here
 :args [[] [:addr]]
 :pfa [:vmaddrlit "offsetof(EnforthVM, dp)" :fetch :exit]}

;; HOLD [CORE] 6.1.1670 ( char -- )
;;
;; Add char to the beginning of the pictured numeric output string.  An
;; ambiguous condition exists if HOLD executes outside of a <# #>
;; delimited number conversion.
{:token :hold
 :args [[:c] []]
 :source ": HOLD ( c -- )   HLD @ 1- DUP HLD ! C! ;"
 :pfa [:hld :fetch :oneminus :dup :hld :store :cstore :exit]}

{:token :invert}

{:token :key}

;; <# [CORE] 6.1.0490 "less-number-sign" ( -- )
;;
;; Initialize the pictured numeric output conversion process.
;
; ---
; : <# ( -- )   HERE HLDEND + HLD ! ;
{:token :lessnumsign
 :name "<#"
 :args [[] []]
 :source ": <# ( -- )   HERE HLDEND + HLD ! ;"
 :pfa [:here :hldend :plus :hld :store :exit]}

{:token :lessthan :name "<"}

{:token :literal
 :args [[:x] []]
 :source ": LITERAL ( x --)
            DUP $FF INVERT AND 0= IF CHARLIT C, C,
            ELSE LIT C, , THEN ;"
 :pfa [:dup :charlit 0xff :invert :and :zeroequals :zbranch 7
         :charlit :charlit :ccomma :ccomma :branch 5
         :charlit :lit :ccomma :comma
       :exit]}

{:token :ltbracket
 :name "["
 :args [[] []]
 :source ": [ ( --)  FALSE STATE ! ;"
 :pfa [:false :state :store :exit]}

{:token :minus :name "-"}

{:token :move}

{:token :mplus :name "M+"}

{:token :nip}

{:token :notequals :name "<>"}

;; # [CORE] 6.1.0030 "number-sign" ( ud1 -- ud2 )
;;
;; Divide ud1 by the number in BASE giving the quotient ud2 and the
;; remainder n.  (n is the least-significant digit of ud1.) Convert n
;; to external form and add the resulting character to the beginning
;; of the pictured numeric output string.  An ambiguous condition
;; exists if # executes outside of a <# #> delimited number
;; conversion.
{:token :numsign
 :name "#"
 :source ": >DIGIT ( u -- c ) DUP 9 > 7 AND + 48 + ;
          : # ( ud1 -- ud2 )   BASE @ UD/MOD ROT >digit HOLD ;"
 :pfa [:base :fetch :udslashmod :rot
       ; TODIGIT
         :dup :charlit 9 :greaterthan :charlit 7 :and
         :plus :charlit 48 :plus
       :hold
       :exit]}

;; #> [CORE] 6.1.0040 "number-sign-greater" ( xd -- c-addr u )
;;
;; Drop xd.  Make the pictured numeric output string available as a
;; character string.  c-addr and u specify the resulting character
;; string.  A program may replace characters within the string.
{:token :numsigngrtr
 :name "#>"
 :args [[:xd] [:caddr :u]]
 :source "#> ( xd -- c-addr u ) DROP DROP  HLD @  HERE HLDEND +  OVER - ;"
 :pfa [:drop :drop :hld :fetch :here :hldend :plus :over :minus :exit]}

;; #S [CORE] 6.1.0050 "number-sign-s" ( ud1 -- ud2 )
;;
;; Convert one digit of ud1 according to the rule for #.  Continue
;; conversion until the quotient is zero.  ud2 is zero.  An ambiguous
;; condition exists if #S executes outside of a <# #> delimited number
;; conversion.
{:token :numsigns
 :name "#S"
 :args [[:ud1] [:ud2]]
 :source ": #S ( ud1 -- 0 )   BEGIN # 2DUP OR WHILE REPEAT ;"
 :pfa [:numsign :twodup :or :zbranch 3 :branch -6 :exit]}

{:token :oneplus :name "1+"}

{:token :oneminus :name "1-"}

{:token :or}

{:token :over}

{:token :plus :name "+"}

{:token :plusstore :name "+!"}

{:token :qdup :name "?DUP"}

;; QUIT [CORE] 6.1.2050 ( -- ) ( R:  i*x -- )
;;
;; Empty the return stack, store zero in SOURCE-ID if it is
;; present, make the user input device the input source, and
;; enter interpretation state.  Do not display a message.
;; Repeat the following:
;;   - Accept a line from the input source into the input
;;     buffer, set >IN to zero, and interpret.
;;   - Display the implementation-defined system prompt if in
;;     interpretation state, all processing has been completed,
;;     and no ambiguous condition exists.
;;
;; ---
;;
;; Offset=124, Length=24 */
{:token :quit
 :args [[] []]
 :source ": QUIT    --; R: i*x --)
            INITRP  0 STATE !
            BEGIN
                TIB  DUP TIBSIZE ACCEPT  SPACE
                INTERPRET
                CR  STATE @ 0= IF .\" ok \" THEN
            AGAIN ;"
 :pfa [:initrp :zero :state :store
         :tib :dup :tibsize :accept :space
         :interpret
         :cr :state :fetch :zeroequals :zbranch 6
         :pdotquote 3 "'o'" "'k'" "' '"
         :branch -18]}

{:token :rfetch :name "R@"}

{:token :rfrom :name "R>"}

{:token :rtbracket
 :name "]"
 :flags #{:immediate}
 :args [[] []]
 :source ": ] ( --)  TRUE STATE ! ; IMMEDIATE"
 :pfa [:true :state :store :exit]}

{:token :rot}

;; ; [CORE] 6.1.0460 semicolon
;;
;; Interpretation:
;;   Interpretation semantics for this word are undefined.
;;
;; Compilation: ( C: colon-sys -- )
;;   Append the run-time semantics below to the current definition.
;;   End the current definition, allow it to be found in the dictionary
;;   and enter interpretation state, consuming colon-sys.  If the
;;   data-space pointer is not aligned, reserve enough data space to
;;   align it.
;;
;; Run-time: ( -- ) ( R: nest-sys -- )
;;   Return to the calling definition specified by nest-sys.
{:token :semicolon
 :name ";"
 :args [[] []]
 :flags #{:immediate}
 :source ": ; ( --)   ['] EXIT COMPILE,  REVEAL  [ ; IMMEDIATE"
 :pfa [:charlit :exit :compilecomma :reveal :ltbracket :exit]}

;; SIGN [CORE] 6.1.2210 ( n -- )
;;
;; If n is negative, add a minus sign to the beginning of the pictured
;; numeric output string.  An ambiguous condition exists if SIGN
;; executes outside of a <# #> delimited number conversion.
;;
;; ---
;; : SIGN ( n -- )   0< IF [CHAR] - HOLD THEN ;
;; ZEROLESS, ZBRANCH, 4, CHARLIT, '-', HOLD, EXIT, 0,
{:token :sign
 :args [[:n] []]
 :source ": SIGN ( n -- )   0< IF [CHAR] - HOLD THEN ;"
 :pfa [:zeroless :zbranch 4 :charlit "'-'" :hold :exit]}

{:token :slashstring :name "/STRING"}

{:token :source
 :args [[] [:caddr :u]]
 :pfa [:vmaddrlit "offsetof(EnforthVM, source_len)" :twofetch :exit]}

{:token :space
 :args [[] []]
 :source ": SPACE ( --)  BL EMIT ;"
 :pfa [:bl :emit :exit]}

{:token :state
 :args [[] [:aaddr]]
 :pfa [:vmaddrlit "offsetof(EnforthVM, state)" :exit]}

{:token :store :name "!"}

{:token :swap}

{:token :tobody
 :name ">BODY"
 :args [[:xt] [:f]]
 :source ": FFI? ( xt -- f)  >CFA C@ kDefTypeFFI0 1- > ;
          : >BODY ( xt -- a-addr)
            DUP >CFA 1+  SWAP FFI? IF EXIT THEN
            BEGIN DUP C@ $80 AND 0= WHILE 1+ REPEAT 1+ ;"
 :pfa [:dup :tocfa :oneplus :swap
       ; FFI?
         :tocfa :cfetch :charlit "kDefTypeFFI0-1" :greaterthan
       :zbranch 2 :exit
       :dup :cfetch :charlit 0x80 :and :zeroequals :zbranch 4
         :oneplus :branch -10
       :oneplus
       :exit]}

{:token :toin
 :name ">IN"
 :args [[] [:aaddr]]
 :pfa [:vmaddrlit "offsetof(EnforthVM, to_in)" :exit]}

;; >NUMBER [CORE] 6.1.0567 "to-number" ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
;;
;; ud2 is the unsigned result of converting the characters
;; within the string specified by c-addr1 u1 into digits, using
;; the number in BASE, and adding each into ud1 after
;; multiplying ud1 by the number in BASE.  Conversion continues
;; left-to-right until a character that is not convertible,
;; including any "+" or "-", is encountered or the string is
;; entirely converted.  c-addr2 is the location of the first
;; unconverted character or the first character past the end of
;; the string if the string was entirely converted.  u2 is the
;; number of unconverted characters in the string.  An ambiguous
;; condition exists if ud2 overflows during the conversion.
{:token :tonumber
 :name ">NUMBER"
 :args [[:ud1 :u1] [:u2]]
 :source ": UD* ( ud1 u1 -- ud2)   DUP >R UM* DROP  SWAP R> UM* ROT + ;
          : >NUMBER ( ud1 c-addr1 u1 -- ud2 c-addr2 u2)
            BEGIN DUP WHILE
               OVER C@ DIGIT?  0= IF DROP EXIT THEN
               >R 2SWAP BASE @ UD* R> M+ 2SWAP
               1 /STRING
            REPEAT ;"
 :pfa [:dup :zbranch 30
         :over :cfetch :digitq :zeroequals :zbranch 3 :drop :exit
         :tor :twoswap :base :fetch
         ; UD*
           :dup :tor :umstar :drop :swap :rfrom :umstar :rot :plus
         :rfrom :mplus :twoswap
         :charlit 1 :slashstring
         :branch -31
       :exit]}

{:token :tor :name ">R"}

{:token :true}

{:token :tuck}

{:token :twodrop :name "2DROP"}

{:token :twodup :name "2DUP"}

{:token :twofetch :name "2@"}

{:token :twostore :name "2!"}

{:token :twoswap :name "2SWAP"}

{:token :twoover :name "2OVER"}

{:token :type
 :args [[:caddr :u] []]
 :source ": TYPE ( c-addr u --)
            OVER + SWAP  ( ca-end ca-next)
            BEGIN 2DUP <> WHILE DUP C@ EMIT 1+ REPEAT 2DROP ;"
 :pfa [:over :plus :swap
       :twodup :notequals :zbranch 7
         :dup :cfetch :emit :oneplus :branch -9
       :twodrop
       :exit]}

;; U. [CORE] 6.1.2320 u-dot ( u -- )
;;
;; Display u in free field format.
{:token :udot
 :name "U."
 :args [[:u] []]
 :source ": U. ( u --)  0 <# #S #> TYPE SPACE ;"
 :pfa [:zero :lessnumsign :numsigns :numsigngrtr :type :space :exit]}

{:token :ugreaterthan :name "U>"}

{:token :umstar :name "UM*"}

{:token :zeroequals :name "0="}

{:token :zeroless :name "0<"}
