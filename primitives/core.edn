{:token :abort}

{:token :abs}

;; ACCEPT [CORE] 6.1.0695 ( c-addr +n1 -- +n2 )
;;
;; Receive a string of at most +n1 characters.  An ambiguous condition
;; exists if +n1 is zero or greater than 32,767.  Display graphic
;; characters as they are received.  A program that depends on the
;; presence or absence of non-graphic characters in the string has an
;; environmental dependency.  The editing functions, if any, that the
;; system performs in order to construct the string are
;; implementation-defined.
;;
;; Input terminates when an implementation-defined line terminator is
;; received.  When input terminates, nothing is appended to the string,
;; and the display is maintained in an implementation-defined way.
;;
;; +n2 is the length of the string stored at c-addr.
{:token :accept
 :args [[:c-addr :n1] [:n2]]
 :source ": ACCEPT ( c-addr max -- n)
            OVER + OVER ( ca-start ca-end ca-dest)
            BEGIN  KEY  DUP 10 <> WHILE
              DUP 8 =  OVER 127 =  OR IF ( cas cae cad bs)
                2OVER DROP NIP ( cas cae cad cas) OVER <> IF
                  ( cas cae cad) 1-  8 EMIT  SPACE  8 EMIT
                THEN
              ELSE
                DUP 2OVER ( cas cae cad c c cae cad) <> IF
                  EMIT OVER C! ( cas cae cad) 1+
                ELSE
                  ( cas cae cad c c) 2DROP
                THEN
              THEN
            REPEAT
            ( ca-start ca-end ca-dest c) DROP NIP SWAP - ;"
 :pfa [:over :plus :over
       :key :dup :icharlit 10 :notequals :izbranch 43
         :dup :icharlit 8 :equals :over :icharlit 127 :equals :or :izbranch 18
           :twoover :drop :nip :over :notequals :izbranch 9
             :oneminus :icharlit 8 :emit :space :icharlit 8 :emit
             :ibranch 13
         :dup :twoover :notequals :izbranch 7
           :emit :over :cstore :oneplus :ibranch 2
           :twodrop
         :ibranch -48
       :drop :nip :swap :minus
       :exit]}

{:token :align
 :args [[] []]
 :source ": ALIGN ( -- )  ( do nothing ) ;"
 :pfa [:exit]}

{:token :allot
 :args [[:n] []]
 :source ": ALLOT ( n -- )  DP +! ;"
 :pfa [:dp :plusstore :exit]}

{:token :and}

{:token :base
 :args [[] [:aaddr]]
 :pfa [:vm :icharlit "offsetof(EnforthVM, base)" :plus :exit]}

{:token :bl
 :args [[] [:c]]
 :source ": BL ( --)  $20 ;"
 :pfa [:icharlit "' '" :exit]}

{:token :ccomma
 :name "C,"
 :args [[:char] []]
 :source ": C, ( char -- )  HERE C!  1 CHARS ALLOT ;"
 :pfa [:here :cstore :icharlit 1 :chars :allot :exit]}

{:token :cells
 :args [[:n1] [:n2]]
 :source ": CELLS ( n1 -- n2 )  kEnforthCellSize * ;"
 :pfa [:icharlit "kEnforthCellSize" :umstar :drop :exit]}

{:token :cfetch :name "C@"}

{:token :chars
 :args [[:n1] [:n2]]
 :source ": CHARS ( n1 -- n2 )  ( do nothing );"
 :pfa [:exit]}

;; : [CORE] 6.1.0450 "colon" ( C: "<spaces>name" -- colon-sys )
;;
;; Skip leading space delimiters.  Parse name delimited by a space.
;; Create a definition for name, called a "colon definition".  Enter
;; compilation state and start the current definition, producing
;; colon-sys.  Append the initiation semantics given below to the
;; current definition.
;;
;; The execution semantics of name will be determined by the words
;; compiled into the body of the definition.  The current definition
;; shall not be findable in the dictionary until it is ended (or until
;; the execution of DOES> in some systems).
;;
;; Initiation: ( i*x -- i*x ) ( R: -- nest-sys )
;;   Save implementation-dependent information nest-sys about the
;;   calling definition.  The stack effects i*x represent arguments to
;;   name.
;;
;; name Execution: ( i*x -- j*x )
;;   Execute the definition name.  The stack effects i*x and j*x
;;   represent arguments to and results from name, respectively.
{:token :colon
 :name ":"
 :args [[] []]
 :source ": : ( \"<spaces>name\" -- )
            CREATE  kDefTypeCOLONHIDDEN CHANGE-LATEST-DEF-TYPE  ] ;"
 :pfa [:create :icharlit "kDefTypeCOLONHIDDEN" :changelatestdeftype
       :rtbracket
       :exit]}

{:token :comma
 :name ","
 :args [[:x] []]
 :source ": , ( x -- )  HERE !  1 CELLS ALLOT ;"
 :pfa [:here :store :icharlit 1 :cells :allot :exit]}

{:token :compilecomma
 :name "COMPILE,"
 :args [[:xt] []]
 :source ": COMPILE, ( xt --)  DUP >[TOKEN] C,  >BODY ?DUP IF 'DICT - XT, THEN ;"
 :pfa [:dup :tocompiletoken :ccomma
       :tobody :qdup :izbranch 8
         ; TICKDICT
           :vm :icharlit "offsetof(EnforthVM, dictionary)" :plus :fetch
         :minus :xtcomma
       :exit]}

{:token :count
 :args [[:caddr1] [:caddr2 :u]]
 :source ": COUNT ( c-addr1 -- c-addr2 u )  DUP C@  SWAP 1+ SWAP ;"
 :pfa [:dup :cfetch :swap :oneplus :swap :exit]}

{:token :cstore :name "C!"}

{:token :cr
 :args [[] []]
 :source ": CR ( --)  $0A EMIT ;"
 :pfa [:icharlit 0x0a :emit :exit]}

{:token :create
 :args [[] []]
 :source ": S, ( ca u --)  TUCK  HERE SWAP MOVE  ALLOT ;
          : CREATE ( \"<spaces>name\" -- )
            BL PARSE-WORD DUP 0= IF ABORT THEN ( ca u)
            HERE >XT  LATEST @ XT,  LATEST ! ( ca u)
            DUP 3 LSHIFT kDefTypeCREATE OR C,  ( ca u) S,  ALIGN ;"
 :pfa [:bl :parseword :dup :zeroequals :izbranch 2 :abort
       :here :toxt :latest :fetch :xtcomma :latest :store
       :dup :icharlit 3 :lshift :icharlit "kDefTypeCREATE" :or :ccomma
       ; S,
         :tuck :here :swap :move :allot
       :align
       :exit]}

{:token :depth}

{:token :dot
 :name "."
 :args [[:n] []]
 :source "BASE @ 10 <>  IF U. EXIT THEN
         DUP ABS 0 <# #S ROT SIGN #> TYPE SPACE ;"
 :pfa [:base :fetch :icharlit 10 :notequals :izbranch 3 :udot :exit
       :dup :abs :zero :lessnumsign :numsigns :rot :sign,
       :numsigngrtr :type :space
       :exit]}

{:token :dup :args [[:x] [:x :x]]}

{:token :drop :args [[:x1 :x2] [:x1]]}

{:token :emit}

{:token :equals :name "="}

;; TODO Implement this properly; probably after we add MFORTH's Input
;; Control Blocks to Enforth..?
{:token :evaluate
 :args [[:caddr :u] []]
 :source ": EVALUATE ( i*x c-addr u -- j*x )  INTERPRET ;"
 :pfa [:interpret :exit]}

{:token :false}

{:token :fetch :name "@"}

;; FIND [CORE] 6.1.1550 ( c-addr -- c-addr 0 | xt 1 | xt -1 )
;;
;; Find the definition named in the counted string at c-addr.  If the
;; definition is not found, return c addr and zero.  If the definition
;; is found, return its execution token xt.  If the definition is
;; immediate, also return one (1), otherwise also return minus-one (-1).
;; For a given string, the values returned by FIND while compiling may
;; differ from those returned while not compiling.
{:token :find
 :args [[:caddr] [[:caddr 0] [:xt 1] [:xt -1]]]
 :source ": FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 ) COUNT FIND-WORD ;"
 :pfa [:count :findword :exit]}

;; EXECUTE [CORE] 6.1.1370 ( i*x xt -- j*x )
;;
;; Remove xt from the stack and perform the semantics identified by it.
;; Other stack effects are due to the word EXECUTEd.
{:token :execute
 :args [[:xt] []]
 :source ": (EXECUTE) ( i*x token w -- j*x) ... ;
          : EXECUTE ( i*x xt -- j*x)  DUP >TOKEN  SWAP >BODY  (EXECUTE) ;"
 :pfa [:dup :totoken :swap :tobody :pexecute :exit]}

{:token :greaterthan :name ">"}

{:token :here
 :args [[] [:addr]]
 :source ": HERE ( -- addr ) DP @ ;"
 :pfa [:dp :fetch :exit]}

;; HOLD [CORE] 6.1.1670 ( char -- )
;;
;; Add char to the beginning of the pictured numeric output string.  An
;; ambiguous condition exists if HOLD executes outside of a <# #>
;; delimited number conversion.
{:token :hold
 :args [[:c] []]
 :source ": HOLD ( c -- )   HLD @ 1- DUP HLD ! C! ;"
 :pfa [:hld :fetch :oneminus :dup :hld :store :cstore :exit]}

{:token :invert}

{:token :key}

;; <# [CORE] 6.1.0490 "less-number-sign" ( -- )
;;
;; Initialize the pictured numeric output conversion process.
;
; ---
; : <# ( -- )   HERE HLDEND + HLD ! ;
{:token :lessnumsign
 :name "<#"
 :args [[] []]
 :source ": <# ( -- )   HERE HLDEND + HLD ! ;"
 :pfa [:here :hldend :plus :hld :store :exit]}

{:token :lessthan :name "<"}

{:token :literal
 :args [[:x] []]
 :source ": LITERAL ( x --)
            DUP $FF INVERT AND 0= IF CHARLIT C, C,
            ELSE LIT C, , THEN ;"
 :pfa [:dup :icharlit 0xff :invert :and :zeroequals :izbranch 7
         :icharlit :charlit :ccomma :ccomma :ibranch 5
         :icharlit :lit :ccomma :comma
       :exit]}

{:token :lshift :args [[:x1 :u] [:x2]]}

{:token :ltbracket
 :name "["
 :args [[] []]
 :source ": [ ( --)  FALSE STATE ! ;"
 :pfa [:false :state :store :exit]}

{:token :minus :name "-"}

{:token :move}

{:token :mplus :name "M+"}

{:token :nip}

{:token :negate}

{:token :notequals :name "<>"}

;; # [CORE] 6.1.0030 "number-sign" ( ud1 -- ud2 )
;;
;; Divide ud1 by the number in BASE giving the quotient ud2 and the
;; remainder n.  (n is the least-significant digit of ud1.) Convert n
;; to external form and add the resulting character to the beginning
;; of the pictured numeric output string.  An ambiguous condition
;; exists if # executes outside of a <# #> delimited number
;; conversion.
{:token :numsign
 :name "#"
 :source ": >DIGIT ( u -- c ) DUP 9 > 7 AND + 48 + ;
          : # ( ud1 -- ud2 )   BASE @ UD/MOD ROT >digit HOLD ;"
 :pfa [:base :fetch :udslashmod :rot
       ; TODIGIT
         :dup :icharlit 9 :greaterthan :icharlit 7 :and
         :plus :icharlit 48 :plus
       :hold
       :exit]}

;; #> [CORE] 6.1.0040 "number-sign-greater" ( xd -- c-addr u )
;;
;; Drop xd.  Make the pictured numeric output string available as a
;; character string.  c-addr and u specify the resulting character
;; string.  A program may replace characters within the string.
{:token :numsigngrtr
 :name "#>"
 :args [[:xd] [:caddr :u]]
 :source "#> ( xd -- c-addr u ) DROP DROP  HLD @  HERE HLDEND +  OVER - ;"
 :pfa [:drop :drop :hld :fetch :here :hldend :plus :over :minus :exit]}

;; #S [CORE] 6.1.0050 "number-sign-s" ( ud1 -- ud2 )
;;
;; Convert one digit of ud1 according to the rule for #.  Continue
;; conversion until the quotient is zero.  ud2 is zero.  An ambiguous
;; condition exists if #S executes outside of a <# #> delimited number
;; conversion.
{:token :numsigns
 :name "#S"
 :args [[:ud1] [:ud2]]
 :source ": #S ( ud1 -- 0 )   BEGIN # 2DUP OR WHILE REPEAT ;"
 :pfa [:numsign :twodup :or :izbranch 3 :ibranch -6 :exit]}

{:token :oneplus :name "1+"}

{:token :oneminus :name "1-"}

{:token :or}

{:token :over}

{:token :plus :name "+"}

{:token :plusstore :name "+!"}

{:token :qdup :name "?DUP"}

;; QUIT [CORE] 6.1.2050 ( -- ) ( R:  i*x -- )
;;
;; Empty the return stack, store zero in SOURCE-ID if it is
;; present, make the user input device the input source, and
;; enter interpretation state.  Do not display a message.
;; Repeat the following:
;;   - Accept a line from the input source into the input
;;     buffer, set >IN to zero, and interpret.
;;   - Display the implementation-defined system prompt if in
;;     interpretation state, all processing has been completed,
;;     and no ambiguous condition exists.
{:token :quit
 :args [[] []]
 :source ": QUIT    --; R: i*x --)
            INITRP  0 STATE !
            BEGIN
                TIB  DUP TIBSIZE ACCEPT  SPACE
                INTERPRET
                CR  STATE @ 0= IF .\" ok \" THEN
            AGAIN ;"
 :pfa [:initrp :zero :state :store
         :tib :dup :tibsize :accept :space
         :interpret
         :cr :state :fetch :zeroequals :izbranch 7
         :pisquote 3 "'o'" "'k'" "' '" :itype
         :ibranch -19]}

{:token :rfetch :name "R@"}

{:token :rfrom :name "R>"}

{:token :rshift :args [[:x1 :u] [:x2]]}

{:token :rtbracket
 :name "]"
 :flags #{:immediate}
 :args [[] []]
 :source ": ] ( --)  TRUE STATE ! ; IMMEDIATE"
 :pfa [:true :state :store :exit]}

{:token :rot}

;; ; [CORE] 6.1.0460 semicolon
;;
;; Interpretation:
;;   Interpretation semantics for this word are undefined.
;;
;; Compilation: ( C: colon-sys -- )
;;   Append the run-time semantics below to the current definition.
;;   End the current definition, allow it to be found in the dictionary
;;   and enter interpretation state, consuming colon-sys.  If the
;;   data-space pointer is not aligned, reserve enough data space to
;;   align it.
;;
;; Run-time: ( -- ) ( R: nest-sys -- )
;;   Return to the calling definition specified by nest-sys.
{:token :semicolon
 :name ";"
 :args [[] []]
 :flags #{:immediate}
 :source ": ; ( --)
            ['] EXIT COMPILE,
            kDefTypeCOLON CHANGE-LATEST-DEF-TYPE
            [ ; IMMEDIATE"
 :pfa [:icharlit :exit :compilecomma
       :icharlit "kDefTypeCOLON" :changelatestdeftype
       :ltbracket :exit]}

;; SIGN [CORE] 6.1.2210 ( n -- )
;;
;; If n is negative, add a minus sign to the beginning of the pictured
;; numeric output string.  An ambiguous condition exists if SIGN
;; executes outside of a <# #> delimited number conversion.
;;
;; ---
;; : SIGN ( n -- )   0< IF [CHAR] - HOLD THEN ;
;; ZEROLESS, ZBRANCH, 4, CHARLIT, '-', HOLD, EXIT, 0,
{:token :sign
 :args [[:n] []]
 :source ": SIGN ( n -- )   0< IF [CHAR] - HOLD THEN ;"
 :pfa [:zeroless :izbranch 4 :icharlit "'-'" :hold :exit]}

{:token :source
 :args [[] [:caddr :u]]
 :pfa [:vm :icharlit "offsetof(EnforthVM, source_len)" :plus :twofetch :exit]}

{:token :space
 :args [[] []]
 :source ": SPACE ( --)  BL EMIT ;"
 :pfa [:bl :emit :exit]}

{:token :state
 :args [[] [:aaddr]]
 :pfa [:vm :icharlit "offsetof(EnforthVM, state)" :plus :exit]}

{:token :store :name "!"}

{:token :swap}

{:token :tobody
 :name ">BODY"
 :args [[:xt] [:a-addr]]
 :source ": >BODY ( xt -- a-addr)
            DUP TOKEN? IF DROP 0 EXIT THEN
            DUP NFA-LENGTH ( xt u)
            SWAP >LFA 2 + ( lfa) 1+ ( flags) + ( nfa) ;"
 :pfa [:dup :tokenq :izbranch 4
         :drop :zero :exit
       :dup :nfalength
       :swap :tolfa :oneplus :oneplus :oneplus :plus
       ;; TODO Add :align if we start aligning the PFA.
       :exit]}

{:token :toin
 :name ">IN"
 :args [[] [:aaddr]]
 :pfa [:vm :icharlit "offsetof(EnforthVM, to_in)" :plus :exit]}

;; >NUMBER [CORE] 6.1.0567 "to-number" ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
;;
;; ud2 is the unsigned result of converting the characters
;; within the string specified by c-addr1 u1 into digits, using
;; the number in BASE, and adding each into ud1 after
;; multiplying ud1 by the number in BASE.  Conversion continues
;; left-to-right until a character that is not convertible,
;; including any "+" or "-", is encountered or the string is
;; entirely converted.  c-addr2 is the location of the first
;; unconverted character or the first character past the end of
;; the string if the string was entirely converted.  u2 is the
;; number of unconverted characters in the string.  An ambiguous
;; condition exists if ud2 overflows during the conversion.
{:token :tonumber
 :name ">NUMBER"
 :args [[:ud1 :caddr1 :u1] [:ud2 :caddr2 :u2]]
 :source ": UD* ( ud1 u1 -- ud2)   DUP >R UM* DROP  SWAP R> UM* ROT + ;
          : >NUMBER ( ud1 c-addr1 u1 -- ud2 c-addr2 u2)
            BEGIN DUP WHILE
               OVER C@ DIGIT?  0= IF EXIT THEN
               >R 2SWAP BASE @ UD* R> M+ 2SWAP
               1 /STRING
            REPEAT ;"
 :pfa [:dup :izbranch 29
         :over :cfetch :digitq :zeroequals :izbranch 2 :exit
         :tor :twoswap :base :fetch
         ; UD*
           :dup :tor :umstar :drop :swap :rfrom :umstar :rot :plus
         :rfrom :mplus :twoswap
         :icharlit 1 :slashstring
         :ibranch -30
       :exit]}

{:token :tor :name ">R"}

{:token :true}

{:token :tuck}

{:token :twodrop :name "2DROP"}

{:token :twodup :name "2DUP"}

{:token :twofetch :name "2@"}

{:token :twostore :name "2!"}

{:token :twoswap :name "2SWAP"}

{:token :twoover :name "2OVER"}

{:token :type
 :args [[:caddr :u] []]
 :source ": TYPE ( c-addr u --)
            OVER + SWAP  ( ca-end ca-next)
            BEGIN 2DUP <> WHILE DUP C@ EMIT 1+ REPEAT 2DROP ;"
 :pfa [:over :plus :swap
       :twodup :notequals :izbranch 7
         :dup :cfetch :emit :oneplus :ibranch -9
       :twodrop
       :exit]}

;; U. [CORE] 6.1.2320 u-dot ( u -- )
;;
;; Display u in free field format.
{:token :udot
 :name "U."
 :args [[:u] []]
 :source ": U. ( u --)  0 <# #S #> TYPE SPACE ;"
 :pfa [:zero :lessnumsign :numsigns :numsigngrtr :type :space :exit]}

{:token :ugreaterthan :name "U>"}

{:token :umstar :name "UM*"}

{:token :zeroequals :name "0="}

{:token :zeroless :name "0<"}
