{:token :branch :flags #{:headerless}}

{:token :cnotsimilar
 :name "C{}"
 :args [[:c1 :c2] [:f]]
 :source ": C{} ( c1 c2 -- f )  C~ INVERT ;"
 :pfa [:csimilar :invert :exit]}

; COLD [MFORTH] ( i*x -- ) ( R: j*x -- )
;
; Clear the screen, display our copyright/help message, then jump to
; ABORT (which clears the stack and calls QUIT, which clears the return
; stack and enters the infinite text interpreter loop).
; TODO Clear the screen
{:token :cold
 :args [[] []]
 :flags #{:headerless}
 :source ": COLD ( i*x -- ; R: j*x -- )
            .\" Enforth -- (C) Michael Alyn Miller\" CR
            ABORT ;"
 :pfa [:pdotquote 31
         "'E'" "'n'" "'f'" "'o'" "'r'" "'t'" "'h'" "' '"
         "'('" "'C'" "')'" "' '" "'M'" "'i'" "'c'" "'h'"
         "'a'" "'e'" "'l'" "' '" "'A'" "'l'" "'y'" "'n'"
         "' '" "'M'" "'i'" "'l'" "'l'" "'e'" "'r'"
       :cr
       :abort
       :exit]}

{:token :csimilar
 :name "C~"
 :args [[:c1 :c2] [:f]]
 :source ": C~ ( c1 c2 -- f )  >UPPER SWAP >UPPER = ;"
 :pfa [:toupper :swap :toupper :equals :exit]}

{:token :cfetchffidefs
 :name "C@FFIDEFS"
 :args [[:u] [:c]]
 :flags #{:headerless}}

{:token :cfetchnames
 :name "C@NAMES"
 :args [[:u] [:c]]
 :flags #{:headerless}}

{:token :changelatestdeftype
 :name "CHANGE-LATEST-DEF-TYPE"
 :args [[:u] []]
 :flags #{:headerless}
 :source ": CHANGE-LATEST-DEF-TYPE ( u --)
            LATEST @ >LFA 2 +  C@ %11111000 AND  OR
            LATEST @ >LFA 2 +  C!"
 :pfa [:latest :fetch :tolfa :oneplus :oneplus :cfetch :charlit 0xF8 :and
       :or :latest :fetch :tolfa :oneplus :oneplus :cstore
       :exit]}

{:token :charlit :flags #{:headerless}}

{:token :cplusstore :name "C+!"}

;; DIGIT? [MFORTH] "digit-question" ( char -- u -1 | 0 )
;;
;; Attempts to convert char to a numeric value using the current BASE.
;; Pushes the numeric value and -1 to the stack if the value was
;; converted, otherwise pushes 0 to the stack.
{:token :digitq
 :name "DIGIT?"
 :args [[:c] [[:u -1] [0]]]
 :flags #{:headerless}
 :source ": DIGIT? ( char -- u -1 | 0)
            >UPPER [CHAR] 0 -
            DUP 0< IF DROP 0 EXIT THEN
            DUP 9 > IF DUP 16 < IF DROP FALSE EXIT ELSE 7 - THEN THEN
            DUP 1+ BASE @ > IF DROP FALSE ELSE TRUE THEN ;"
 :pfa [:toupper :charlit "'0'" :minus
       :dup :zeroless :zbranch 4 :drop :zero :exit
       :dup :charlit 9 :greaterthan :zbranch 13
         :dup :charlit 17 :lessthan :zbranch 4
           :drop :false :exit
           :charlit 7 :minus
       :dup :oneplus :base :fetch :ugreaterthan :zbranch 4
         :drop :false :exit
         :true
       :exit]}

{:token :exit :flags #{:headerless}}

{:token :fetchffidefs
 :name "@FFIDEFS"
 :args [[:u] [:x]]
 :flags #{:headerless}}

{:token :ffiq
 :name "FFI?"
 :args [[:xt] [:f]]
 :flags #{:headerless}
 :source ": FFI? ( xt -- f)  >DEF-TYPE kDefTypeFFI = ;"
 :pfa [:todeftype :charlit "kDefTypeFFI" :equals :exit]}

{:token :ffiarity
 :name "FFI-ARITY"
 :args [[:xt] [:u]]
 :flags #{:headerless}
 :pfa [:toffidef :charlit "offsetof(EnforthFFIDef, arity)" :plus :cfetchffidefs :exit]}

{:token :ffiname
 :name "FFI-NAME"
 :args [[:xt] [:addr]]
 :flags #{:headerless}
 :pfa [:toffidef :charlit "offsetof(EnforthFFIDef, name)" :plus :fetchffidefs :exit]}

{:token :finddef
 :name "FIND-DEF"
 :args [[:caddr :u] [[0] [:xt 1] [:xt -1]]]
 :flags #{:headerless}
 :source ": IMMEDIATE-DEF? ( xt -- f ) >DEF-TYPE kDefTypeCOLONIMMEDIATE = ;
          : FIND-DEF ( c-addr u -- 0 | xt 1 | xt -1 )
          2>R  LATEST @
          BEGIN
            ( xt R:ca u) ?DUP
          WHILE
            DUP 2R@ ROT ( xt ca u xt R:ca u) FOUND-DEF? ( xt f R:ca u)
            IF  DUP IMMEDIATE-DEF? 2 AND 1-  2R> 2DROP  EXIT THEN
            >LFA W@
          REPEAT ( R:ca u) 2R> 2DROP FALSE ;"
 :pfa [:twotor :latest :fetch
       :qdup :zbranch 23
         :dup :tworfetch :rot :founddefq :zbranch 13
           :dup
           ; IMMEDIATE-DEF?
             :todeftype :charlit "kDefTypeCOLONIMMEDIATE" :equals
           :charlit 2 :and :oneminus :tworfrom :twodrop :exit
         :tolfa :wfetch
         :branch -24
       :tworfrom :twodrop :false
       :exit]}

{:token :findprim
 :name "FIND-PRIM"
 :args [[:caddr :u] [[0] [:xt 1] [:xt -1]]]
 :flags #{:headerless}
 :source ": IMMEDIATE-PRIM? ( off -- f ) C@NAMES $7 AND kDefTypeCOLONIMMEDIATE = ;
          : FIND-PRIM ( c-addr u -- 0 | xt 1 | xt -1 )
            2>R  0 0
            BEGIN
              ( token offset R:ca u) DUP C@NAMES $FF <>
            WHILE
              DUP 2R@ ROT ( t off ca u off R:ca u) FOUND-PRIM?
              IF ( t off off2 R:ca u) DROP  IMMEDIATE-PRIM? 2 AND 1-
                2R> 2DROP  EXIT THEN
              ROT 1+ ( off off2 t+1) ROT DROP SWAP ( t+1 off2)
            REPEAT ( token offset R:ca u) 2DROP 2R> 2DROP FALSE ;"
 :pfa [:twotor :zero :zero
       :dup :cfetchnames :charlit 0xff :notequals :zbranch 29
         :dup :tworfetch :rot :foundprimq :zbranch 16
           :drop
           ; IMMEDIATE-PRIM?
             :cfetchnames :charlit 0x07 :and
             :charlit "kDefTypeCOLONIMMEDIATE" :equals
           :charlit 2 :and :oneminus
           :tworfrom :twodrop :exit
         :rot :oneplus :rot :drop :swap
         :branch -34
       :twodrop :tworfrom :twodrop :false
       :exit]}

;; FIND-WORD [Enforth] "paren-find-paren" ( c-addr u -- c-addr u 0 | xt 1 | xt -1 )
;;
;; Find the definition named in the string at c-addr with length u in
;; the word list whose latest definition is pointed to by nfa.  If the
;; definition is not found, return the string and zero.  If the
;; definition is found, return its execution token xt.  If the
;; definition is immediate, also return one (1), otherwise also return
;; minus-one (-1).  For a given string, the values returned by FIND-WORD
;; while compiling may differ from those returned while not compiling.
{:token :findword
 :name "FIND-WORD"
 :args [[:caddr :u] [[:caddr :u 0] [:xt 1] [:xt -1]]]
 :flags #{:headerless}
 :source ": FIND-WORD ( c-addr u -- c-addr u 0 | xt 1 | xt -1 )
            2DUP FIND-DEF ( ca u 0 | ca u xt 1/-1) ?DUP IF 2SWAP 2DROP
            ELSE 2DUP FIND-PRIM ( ca u 0 | ca u xt 1/-1) DUP IF 2SWAP 2DROP
            THEN ;"
 :pfa [:twodup :finddef :qdup :zbranch 5
         :twoswap :twodrop :branch 8
         :twodup :findprim :dup :zbranch 3
           :twoswap :twodrop
         :exit]}

;; FOUND-DEF? [Enforth] "found-def-question" ( c-addr u xt -- f)
;;
;; Compares the string c-addr with length u to the name of the
;; dictionary entry identified by xt and pushes true to the stack if the
;; names are identical (ignoring case), false otherwise.
{:token :founddefq
 :name "FOUND-DEF?"
 :args [[:caddr :u :xt] [:f]]
 :flags #{:headerless}
 :source ": HIDDEN? ( xt -- f ) >DEF-TYPE kDefTypeCOLONHIDDEN = ;
          : STRING~ ( c-addr1 c-addr2 u -- f )
            BEGIN
              ?DUP
            WHILE
              1- >R ( ca1 ca2 R:u'-1)
              OVER C@  OVER C@ C{} IF 2DROP R> DROP FALSE EXIT THEN
              1+ SWAP 1+ SWAP ( ca1' ca2' R:u'-1) R>
            REPEAT ( ca' ca2') 2DROP TRUE ;
          : FOUND-DEF? ( c-addr u xt -- f)
            DUP HIDDEN? IF DROP 2DROP FALSE EXIT THEN
            2DUP NAME-LENGTH ( ca u xt u u') <> IF DROP 2DROP FALSE EXIT THEN
            DUP FFI? IF ( ca u xt) FOUND-FFI? EXIT THEN
            >LFA 2 + 1+ ( ca u ca') SWAP STRING~ ;"
 :pfa [:dup
       ; HIDDEN
         :todeftype :charlit "kDefTypeCOLONHIDDEN" :equals
       :zbranch 5
         :drop :twodrop :false :exit
       :twodup :namelength :notequals :zbranch 5
         :drop :twodrop :false :exit
       :dup :ffiq :zbranch 3
         :foundffiq :exit
       :tolfa :oneplus :oneplus :oneplus :swap
       ; STRING~
         :qdup :zbranch 22
           :oneminus :tor
           :over :cfetch :over :cfetch :cnotsimilar :zbranch 6
             :twodrop :rfrom :drop :false :exit
           :oneplus :swap :oneplus :swap :rfrom
           :branch -23
         :twodrop :true
       :exit]}

{:token :foundffiq
 :name "FOUND-FFI?"
 :args [[:caddr :u :xt] [:f]]
 :flags #{:headerless}
 :source ": FOUND-FFI? ( c-addr u xt -- f )
            FFI-NAME SWAP ( c-addr c-addrffi u)
            BEGIN
              ?DUP
            WHILE
              1- >R ( ca caffi R:u'-1)
              OVER C@  OVER C@FFIDEFS C{} IF 2DROP R> DROP FALSE EXIT THEN
              1+ SWAP 1+ SWAP ( ca' caffi' R:u'-1) R>
            REPEAT ( ca' caffi') 2DROP TRUE ;"
 :pfa [:ffiname :swap
       :qdup :zbranch 22
         :oneminus :tor
         :over :cfetch :over :cfetchffidefs :cnotsimilar :zbranch 6
           :twodrop :rfrom :drop :false :exit
         :oneplus :swap :oneplus :swap :rfrom :branch -23
        :twodrop :true
        :exit]}

{:token :foundprimq
 :name "FOUND-PRIM?"
 :args [[:caddr :u :offset1] [:offset2 :f]]
 :flags #{:headerless}
 :source ": PRIM-NAME-LENGTH ( off -- u )  C@NAMES 3 RSHIFT ;
          : TRAVERSE-PRIM-NAME ( off1 -- off2 )  DUP PRIM-NAME-LENGTH + 1+ ;
          : FOUND-PRIM? ( c-addr u off1 -- off2 f )
            DUP TRAVERSE-PRIM-NAME >R ( ca u off1 R:off2)
            DUP PRIM-NAME-LENGTH ROT <> IF 2DROP R> FALSE EXIT THEN
            1+ BEGIN ( ca off1+1 R:off2)
              OVER C@  OVER C@NAMES C{} IF 2DROP R> FALSE EXIT THEN
              1+ SWAP 1+ SWAP ( ca' off' R:off2)
              DUP R@ =
            UNTIL
            ( ca' off' R:off2) 2DROP R> TRUE ;"
 :pfa [:dup
       ; TRAVERSE-PRIM-NAME
         :dup
         ; PRIM-NAME-LENGTH
           :cfetchnames :charlit 3 :rshift
         :plus :oneplus
       :tor
       :dup
       ; PRIM-NAME-LENGTH
         :cfetchnames :charlit 3 :rshift
       :rot :notequals :zbranch 5
           :twodrop :rfrom :false :exit
       :oneplus
         :over :cfetch :over :cfetchnames :cnotsimilar :zbranch 5
           :twodrop :rfrom :false :exit
         :oneplus :swap :oneplus :swap
         :dup :rfetch :equals :zbranch -19
         :twodrop :rfrom :true
       :exit]}

{:token :halt
 :flags #{:headerless}
 :source ": HALT ( i*x -- )  (HALT) ;"
 :pfa [:phalt :exit]}

{:token :hld
 :args [[] [:aaddr]]
 :flags #{:headerless}
 :pfa [:vmaddrlit "offsetof(EnforthVM, hld)" :exit]}

{:token :hldend
 :args [[] [:c]]
 :flags #{:headerless}
 :source ": HLDEND ( -- u)  [ 1 CELLS 8 * 3 * ] ;"
 :pfa [:charlit "kEnforthCellSize * 8 * 3" :exit]}

{:token :initrp :flags #{:headerless}}

{:token :interpret
 :args [[:caddr :u] []]
 :flags #{:headerless}
 :source ": INTERPRET ( i*x c-addr u -- j*x )
            'SOURCELEN 2!  0 >IN !
            BEGIN  BL PARSE-WORD  DUP WHILE
              FIND-WORD ( ca u 0=notfound | xt 1=imm | xt -1=interp)
              ?DUP IF ( xt 1=imm | xt -1=interp)
                1+  STATE @ 0=  OR ( xt 2=imm | xt 0=interp)
                IF EXECUTE ELSE COMPILE, THEN
              ELSE
                NUMBER? IF
                  STATE @ IF POSTPONE LITERAL THEN
                  -- Interpreting; leave number on stack.
                ELSE
                  TYPE  SPACE  [CHAR] ? EMIT  CR  ABORT
                THEN
              THEN
            REPEAT ( j*x ca u) 2DROP ;"
 :pfa [:vmaddrlit "offsetof(EnforthVM, source_len)" :twostore
       :zero :toin :store
         :bl :parseword :dup :zbranch 37
           :findword :qdup :zbranch 14
             :oneplus :state :fetch :zeroequals :or :zbranch 4
             :execute :branch 21
             :compilecomma :branch 18
           :numberq :zbranch 8
             :state :fetch :zbranch 11
               :literal :branch 8
             :type :space :charlit "'?'" :emit :cr :abort
           :branch -40
       :twodrop
       :exit]}

{:token :latest
 :args [[] [:aaadr]]
 :pfa [:vmaddrlit "offsetof(EnforthVM, latest)" :exit]}

{:token :lit
 :name "(LIT)"
 :args [[] [:x]]
 :flags #{:headerless}}

;; Length of the definition name, not necessarily the NFA field (because
;; FFI trampolines have a zero-length NFA since the name is stored in
;; ROM in the FFI definition).
{:token :namelength
 :name "NAME-LENGTH"
 :args [[:xt] [:u]]
 :flags #{:headerless}
 :source ": NAME-LENGTH ( xt -- ru)  >LFA 2 + C@ 3 RSHIFT ;"
 :pfa [:tolfa :oneplus :oneplus :cfetch :charlit 3 :rshift :exit]}

;; Length of the NFA field, not necessarily the name itself (because FFI
;; trampolines have a zero-length NFA since the name is stored in ROM in
;; the FFI definition).
{:token :nfalength
 :name "NFA-LENGTH"
 :args [[:xt] [:u]]
 :flags #{:headerless}
 :source ": NFA-LENGTH ( xt -- ru)
            DUP FFI? IF DROP 0 ELSE >LFA 2 + C@ 3 RSHIFT THEN ;"
 :pfa [:dup :ffiq :zbranch 5
         :drop :zero :branch 8
         :tolfa :oneplus :oneplus :cfetch :charlit 3 :rshift
       :exit]}

;; NUMBER? [ENFORTH] "number-question" ( c-addr u -- c-addr u 0 | n -1 )
;;
;; Attempt to convert a string at c-addr of length u into digits, using
;; the radix in BASE.  The number and -1 is returned if the conversion
;; was successful, otherwise 0 is returned.
{:token :numberq
 :name "NUMBER?"
 :args [[:caddr :u] [[:caddr :u 0] [:n -1]]]
 :flags #{:headerless}
 :source ": SIGN? ( ca1 u1 -- ca2 u2 f )
            OVER  C@  DUP [CHAR] - =  OVER [CHAR] + = OR  IF
                [CHAR] - = IF -1 ELSE 0 THEN  >R 1 /STRING R>
            ELSE DROP 0 THEN ;
          : ?NEGATE ( n1 n2 -- n3)   0< IF NEGATE THEN ;
          : NUMBER? ( c-addr u -- c-addr u 0 | n -1)
            SIGN? >R  2DUP 0 0 2SWAP  >NUMBER  ( ca u ud ca2 u2)
            IF DROP 2DROP  R> DROP  0 ELSE
               DROP 2NIP DROP  R> ?NEGATE  -1 THEN ;"
 :pfa [; SIGN?
         :over :cfetch :dup :charlit "'-'" :equals
         :over :charlit "'+'" :equals :or :zbranch 17
           :charlit "'-'" :equals :zbranch 4
             :true :branch 2
             :false
           :tor :charlit 1 :slashstring :rfrom :branch 3
           :drop :zero
       :tor :twodup :zero :zero :twoswap :tonumber :zbranch 8
         :drop :twodrop :rfrom :drop :zero :branch 10
         :drop :twonip :drop :rfrom
         ; ?NEGATE
           :zeroless :zbranch 2 :negate
         :true
       :exit]}

;; PARSE-WORD [MFORTH] "parse-word" ( char "ccc<char>" -- c-addr u )
;;
;; Parse ccc delimited by the delimiter char, skipping leading
;; delimiters.
;;
;; c-addr is the address (within the input buffer) and u is the length
;; of the parsed string.  If the parse area was empty, the resulting
;; string has a zero length.
{:token :parseword
 :args [[:caddr :u1 :c] [:caddr2 :u2]]
 :flags #{:headerless}
 :source ": SKIP-DELIM ( c-addr1 u1 c -- c-addr2 u2)
            >R  BEGIN  OVER C@  R@ =  ( ca u f R:c) OVER  AND WHILE
               1 /STRING REPEAT  R> DROP ;
          : FIND-DELIM ( c-addr1 u1 c -- c-addr2)
            >R  BEGIN  OVER C@  R@ <>  ( ca u f R:c) OVER  AND WHILE
               1 /STRING REPEAT  R> 2DROP ;
          : PARSE-WORD ( c -- c-addr u)
            >R  SOURCE >IN @ /STRING ( ca-parse u-parse R:c)
            R@ SKIP-DELIM ( ca u R:c)  OVER SWAP ( ca-word ca-word u R:c)
            R> FIND-DELIM ( ca-word ca-delim)
            DUP SOURCE DROP ( caw cad cad cas) - >IN ! ( caw cad)
            OVER - ;"
 :pfa [:tor :source :toin :fetch :slashstring
       :rfetch
         ; SKIP-DELIM
         :tor
         :over :cfetch :rfetch :equals :over :and :zbranch 6
           :charlit 1 :slashstring :branch -12
         :rfrom :drop
       :over :swap
       :rfrom
         ; FIND-DELIM
         :tor
           :over :cfetch :rfetch :notequals :over :and :zbranch 6
           :charlit 1 :slashstring :branch -12
         :rfrom :twodrop
       :dup :source :drop :minus :toin :store
       :over :minus
       :exit]}

{:token :pdotquote :name "(.\")" :flags #{:headerless}}

{:token :pexecute :name "(EXECUTE)" :flags #{:headerless}}

{:token :phalt :flags #{:headerless}}

{:token :psquote :name "(s\")" :flags #{:headerless}}

{:token :tib
 :args [[] [:caadr]]
 :flags #{:headerless}
 :pfa [:vmaddrlit "offsetof(EnforthVM, tib)" :exit]}

;; TODO Put TIBSIZE in a constant.
{:token :tibsize
 :args [[] [:u]]
 :flags #{:headerless}
 :pfa [:charlit 80 :exit]}

;; >[TOKEN] [ENFORTH] "to-compile-token" ( xt -- token )
;;
;; Return the compilation token for the given XT, which may refer to a
;; token, user definition, or FFI trampoline.
{:token :tocompiletoken
 :name ">[TOKEN]"
 :args [[:xt] [:token]]
 :flags #{:headerless}
 :source ": >[TOKEN] ( xt -- token)
            >TOKEN  DUP EXECUTION-TOKEN-BASE 1- > IF 0x10 + THEN ;"
 :pfa [:totoken :dup :charlit "0xe0 - 1" :greaterthan :zbranch 4
         :charlit 0x10 :plus
       :exit]}

;; xt must refer to a compiled (not primitive) definition or FFI
;; trampoline.
{:token :todeftype
 :name ">DEF-TYPE"
 :args [[:xt] [:u]]
 :flags #{:headerless}
 :source ": >DEF-TYPE ( xt -- u)  >LFA 2 + C@ $7 AND ;"
 :pfa [:tolfa :oneplus :oneplus :cfetch :charlit 0x07 :and :exit]}

{:token :tokenq
 :name "TOKEN?"
 :flags #{:headerless}
 :source ": TOKEN? ( xt -- f)  $8000 AND 0= ;"
 :pfa [:wlit 0x00 0x80 :and :zeroequals :exit]}

;; xt must refer to a compiled (not primitive) definition or FFI
;; trampoline.
{:token :tolfa
 :name ">LFA"
 :args [[:xt] [:a-addr]]
 :flags #{:headerless}
 :source ": >LFA ( xt -- a-addr)  $7FFF AND 'DICT + ;"
 :pfa [:wlit 0xff 0x7f :and
       ; 'DICT
         :vmaddrlit "offsetof(EnforthVM, dictionary)" :fetch
       :plus
       :exit]}

{:token :toffidef
 :name ">FFIDEF"
 :args [[:xt] [:addr]]
 :flags #{:headerless}
 :source ": >FFIDEF ( xt -- addr ) >BODY @ ;"
 :pfa [:tobody :fetch :exit]}

;; >TOKEN [ENFORTH] "to-token" ( xt -- token )
;;
;; Return the execution token for the given XT, which may refer to a
;; token, user definition, or FFI trampoline.
{:token :totoken
 :name ">TOKEN"
 :args [[:xt] [:token]]
 :flags #{:headerless}
 :source ": >TOKEN ( xt -- token)
            DUP TOKEN? IF EXIT THEN
            DUP FFI? IF FFI-ARITY FFI-EXECUTION-TOKEN-BASE +
            ELSE >DEF-TYPE EXECUTION-TOKEN-BASE + THEN ;"
 :pfa [:dup :tokenq :zbranch 2 :exit
       :dup :ffiq :zbranch 7
         :ffiarity :charlit 0xe8 :plus :branch 5
         :todeftype :charlit 0xe0 :plus
       :exit]}

{:token :toupper
 :name ">UPPER"
 :args [[:c] [:c]]
 :source ": >UPPER ( c -- c )
            DUP [CHAR] a 1- > ( c f)
            OVER z 1+ < (c f f)
            AND IF 0x20 - THEN ;"
 :pfa [:dup :charlit "'a'" :oneminus :greaterthan
       :over :charlit "'z'" :oneplus :lessthan
       :and :zbranch 4
         :charlit 0x20 :minus
       :exit]}

{:token :twonip
 :name "2NIP"
 :args [[:x1 :x2 :x3 :x4] [:x3 :x4]]}

{:token :udslashmod :flags #{:headerless}}

{:token :vmaddrlit :flags #{:headerless}}

{:token :wcomma :name "W," :flags #{:headerless}}

{:token :wfetch :name "W@" :flags #{:headerless}}

{:token :wlit :flags #{:headerless}}

{:token :zbranch :name "0BRANCH" :flags #{:headerless}}

{:token :zero :name "0"}
