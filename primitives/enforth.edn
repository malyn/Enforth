{:token :branch :flags #{:headerless}}

{:token :changelatestdeftype
 :name "CHANGE-LATEST-DEF-TYPE"
 :args [[:u] []]
 :flags #{:headerless}
 :source ": CHANGE-LATEST-DEF-TYPE ( u --)
            LATEST @ >LFA 2 +  C@ %11111000 AND  OR
            LATEST @ >LFA 2 +  C!"
 :pfa [:latest :fetch :tolfa :oneplus :oneplus :cfetch :charlit 0xF8 :and
       :or :latest :fetch :tolfa :oneplus :oneplus :cstore
       :exit]}

{:token :charlit :flags #{:headerless}}

{:token :cplusstore :name "C+!"}

;; DIGIT? [MFORTH] "digit-question" ( char -- u -1 | 0 )
;;
;; Attempts to convert char to a numeric value using the current BASE.
;; Pushes the numeric value and -1 to the stack if the value was
;; converted, otherwise pushes 0 to the stack.
{:token :digitq
 :name "DIGIT?"
 :args [[:c] [[:u -1] [0]]]
 :flags #{:headerless}
 :source ": DIGIT? ( char -- u -1 | 0)
            [CHAR] 0 -
            DUP 0< IF DROP 0 EXIT THEN
            DUP 9 > IF DUP 16 < IF DROP FALSE EXIT ELSE 7 - THEN THEN
            DUP 1+ BASE @ > IF DROP FALSE ELSE TRUE THEN ;"
 :pfa [:charlit "'0'" :minus
       :dup :zeroless :zbranch 4 :drop :zero :exit
       :dup :charlit 9 :greaterthan :zbranch 13
         :dup :charlit 17 :lessthan :zbranch 4
           :drop :false :exit
           :charlit 7 :minus
       :dup :oneplus :base :fetch :ugreaterthan :zbranch 4
         :drop :false :exit
         :true
       :exit]}

{:token :exit :flags #{:headerless}}

{:token :ffiq
 :name "FFI?"
 :args [[:xt] [:f]]
 :flags #{:headerless}
 :source ": FFI? ( xt -- f)  >DEF-TYPE kDefTypeFFI = ;"
 :pfa [:todeftype :charlit "kDefTypeFFI" :equals :exit]}

{:token :ffiarity
 :name "FFI-ARITY"
 :args [[:xt] [:u]]
 :flags #{:headerless}}

{:token :findword :name "FIND-WORD" :flags #{:headerless}}

{:token :hld
 :args [[] [:aaddr]]
 :flags #{:headerless}
 :pfa [:vmaddrlit "offsetof(EnforthVM, hld)" :exit]}

{:token :hldend
 :args [[] [:c]]
 :flags #{:headerless}
 :source ": HLDEND ( -- u)  [ 1 CELLS 8 * 3 * ] ;"
 :pfa [:charlit "kEnforthCellSize * 8 * 3" :exit]}

{:token :initrp :flags #{:headerless}}

{:token :interpret
 :args [[:caddr :u] []]
 :flags #{:headerless}
 :source ": INTERPRET ( i*x c-addr u -- j*x )
            'SOURCELEN 2!  0 >IN !
            BEGIN  BL PARSE-WORD  DUP WHILE
              FIND-WORD ( ca u 0=notfound | xt 1=imm | xt -1=interp)
              ?DUP IF ( xt 1=imm | xt -1=interp)
                1+  STATE @ 0=  OR ( xt 2=imm | xt 0=interp)
                IF EXECUTE ELSE COMPILE, THEN
              ELSE
                NUMBER? IF
                  STATE @ IF POSTPONE LITERAL THEN
                  -- Interpreting; leave number on stack.
                ELSE
                  TYPE  SPACE  [CHAR] ? EMIT  CR  ABORT
                THEN
              THEN
            REPEAT ( j*x ca u) 2DROP ;"
 :pfa [:vmaddrlit "offsetof(EnforthVM, source_len)" :twostore
       :zero :toin :store
         :bl :parseword :dup :zbranch 37
           :findword :qdup :zbranch 14
             :oneplus :state :fetch :zeroequals :or :zbranch 4
             :execute :branch 21
             :compilecomma :branch 18
           :numberq :zbranch 8
             :state :fetch :zbranch 11
               :literal :branch 8
             :type :space :charlit "'?'" :emit :cr :abort
           :branch -40
       :twodrop
       :exit]}

{:token :latest
 :args [[] [:aaadr]]
 :pfa [:vmaddrlit "offsetof(EnforthVM, latest)" :exit]}

{:token :lit
 :name "(LIT)"
 :args [[] [:x]]
 :flags #{:headerless}}

;; Length of the NFA field, not necessarily the name itself (because FFI
;; trampolines have a zero-length NFA since the name is stored in ROM in
;; the FFI definition).
{:token :nfalength
 :name "NFA-LENGTH"
 :args [[:xt] [:u]]
 :flags #{:headerless}
 :source ": NFA-LENGTH ( xt -- ru)
            DUP FFI? IF DROP 0 ELSE >LFA 2 + C@ 3 RSHIFT THEN ;"
 :pfa [:dup :ffiq :zbranch 5
         :drop :zero :branch 8
         :tolfa :oneplus :oneplus :cfetch :charlit 3 :rshift
       :exit]}

;; NUMBER? [ENFORTH] "number-question" ( c-addr u -- c-addr u 0 | n -1 )
;;
;; Attempt to convert a string at c-addr of length u into digits, using
;; the radix in BASE.  The number and -1 is returned if the conversion
;; was successful, otherwise 0 is returned.
;;
;; TODO Implement this for real.
{:token :numberq
 :name "NUMBER?"
 :args [[:caddr :u] [[:caddr :u 0] [:n -1]]]
 :flags #{:headerless}
 :source ": NUMBER? ( c-addr u -- c-addr u 0 | n -1)
            0 0 2SWAP >NUMBER 2DROP DROP TRUE ;"
 :pfa [:zero :zero :twoswap :tonumber :twodrop :drop :true :exit]}

;; PARSE-WORD [MFORTH] "parse-word" ( char "ccc<char>" -- c-addr u )
;;
;; Parse ccc delimited by the delimiter char, skipping leading
;; delimiters.
;;
;; c-addr is the address (within the input buffer) and u is the length
;; of the parsed string.  If the parse area was empty, the resulting
;; string has a zero length.
{:token :parseword
 :args [[:caddr :u1 :c] [:caddr2 :u2]]
 :flags #{:headerless}
 :source ": SKIP-DELIM ( c-addr1 u1 c -- c-addr2 u2)
            >R  BEGIN  OVER C@  R@ =  ( ca u f R:c) OVER  AND WHILE
               1 /STRING REPEAT  R> DROP ;
          : FIND-DELIM ( c-addr1 u1 c -- c-addr2)
            >R  BEGIN  OVER C@  R@ <>  ( ca u f R:c) OVER  AND WHILE
               1 /STRING REPEAT  R> 2DROP ;
          : PARSE-WORD ( c -- c-addr u)
            >R  SOURCE >IN @ /STRING ( ca-parse u-parse R:c)
            R@ SKIP-DELIM ( ca u R:c)  OVER SWAP ( ca-word ca-word u R:c)
            R> FIND-DELIM ( ca-word ca-delim)
            DUP SOURCE DROP ( caw cad cad cas) - >IN ! ( caw cad)
            OVER - ;"
 :pfa [:tor :source :toin :fetch :slashstring
       :rfetch
         ; SKIP-DELIM
         :tor
         :over :cfetch :rfetch :equals :over :and :zbranch 6
           :charlit 1 :slashstring :branch -12
         :rfrom :drop
       :over :swap
       :rfrom
         ; FIND-DELIM
         :tor
           :over :cfetch :rfetch :notequals :over :and :zbranch 6
           :charlit 1 :slashstring :branch -12
         :rfrom :twodrop
       :dup :source :drop :minus :toin :store
       :over :minus
       :exit]}

{:token :pexecute :name "(EXECUTE)" :flags #{:headerless}}

{:token :pdotquote :name "(.\")" :flags #{:headerless}}

{:token :psquote :name "(s\")" :flags #{:headerless}}

{:token :tib
 :args [[] [:caadr]]
 :flags #{:headerless}
 :pfa [:vmaddrlit "offsetof(EnforthVM, tib)" :exit]}

;; TODO Put TIBSIZE in a constant.
{:token :tibsize
 :args [[] [:u]]
 :flags #{:headerless}
 :pfa [:charlit 80 :exit]}

;; xt must refer to a compiled (not primitive) definition or FFI
;; trampoline.
{:token :todeftype
 :name ">DEF-TYPE"
 :args [[:xt] [:u]]
 :flags #{:headerless}
 :source ": >DEF-TYPE ( xt -- u)  >LFA 2 + C@ $7 AND ;"
 :pfa [:tolfa :oneplus :oneplus :cfetch :charlit 0x07 :and :exit]}

{:token :tokenq
 :name "TOKEN?"
 :flags #{:headerless}
 :source ": TOKEN? ( xt -- f)  $8000 AND 0= ;"
 :pfa [:wlit 0x00 0x80 :and :zeroequals :exit]}

;; xt must refer to a compiled (not primitive) definition or FFI
;; trampoline.
{:token :tolfa
 :name ">LFA"
 :args [[:xt] [:a-addr]]
 :flags #{:headerless}
 :source ": >LFA ( xt -- a-addr)  $7FFF AND 'DICT + ;"
 :pfa [:wlit 0xff 0x7f :and
       ; 'DICT
         :vmaddrlit "offsetof(EnforthVM, dictionary)" :fetch
       :plus
       :exit]}

;; >TOKEN [ENFORTH] "to-token" ( xt -- token )
;;
;; Return the execution token for the given XT, which may refer to a
;; token, user definition, or FFI trampoline.
{:token :totoken
 :name ">TOKEN"
 :args [[:xt] [:token]]
 :flags #{:headerless}
 :source ": >TOKEN ( xt -- token)
            DUP TOKEN? IF EXIT THEN
            DUP FFI? IF FFI-ARITY FFI-EXECUTION-TOKEN-BASE +
            ELSE >DEF-TYPE EXECUTION-TOKEN-BASE + THEN ;"
 :pfa [:dup :tokenq :zbranch 2 :exit
       :dup :ffiq :zbranch 7
         :ffiarity :charlit 0xe8 :plus :branch 5
         :todeftype :charlit 0xe0 :plus
       :exit]}

;; >[TOKEN] [ENFORTH] "to-compile-token" ( xt -- token )
;;
;; Return the compilation token for the given XT, which may refer to a
;; token, user definition, or FFI trampoline.
{:token :tocompiletoken
 :name ">[TOKEN]"
 :args [[:xt] [:token]]
 :flags #{:headerless}
 :source ": >[TOKEN] ( xt -- token)
            >TOKEN  DUP EXECUTION-TOKEN-BASE 1- > IF 0x10 + THEN ;"
 :pfa [:totoken :dup :charlit "0xe0 - 1" :greaterthan :zbranch 4
         :charlit 0x10 :plus
       :exit]}

{:token :udslashmod :flags #{:headerless}}

{:token :vmaddrlit :flags #{:headerless}}

{:token :wcomma :name "W," :flags #{:headerless}}

{:token :wlit :flags #{:headerless}}

{:token :zbranch :name "0BRANCH" :flags #{:headerless}}

{:token :zero :name "0"}
