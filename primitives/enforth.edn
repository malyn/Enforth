{:token :branch :flags #{:headerless}}

{:token :cnotsimilar
 :name "C{}"
 :args [[:c1 :c2] [:f]]
 :source ": C{} ( c1 c2 -- f )  C~ INVERT ;"
 :pfa [:csimilar :invert :exit]}

; COLD [Enforth] ( i*x -- ) ( R: j*x -- )
;
; Clear the screen, display our copyright/help message, then jump to
; ABORT (which clears the stack and calls QUIT, which clears the return
; stack and enters the infinite text interpreter loop).
; TODO Clear the screen
{:token :cold
 :args [[] []]
 :flags #{:headerless}
 :source ": COLD ( i*x -- ; R: j*x -- )
            .\" Enforth -- (C) Michael Alyn Miller\" CR
            ABORT ;"
 :pfa [:pisquote 31
         "'E'" "'n'" "'f'" "'o'" "'r'" "'t'" "'h'" "' '"
         "'('" "'C'" "')'" "' '" "'M'" "'i'" "'c'" "'h'"
         "'a'" "'e'" "'l'" "' '" "'A'" "'l'" "'y'" "'n'"
         "' '" "'M'" "'i'" "'l'" "'l'" "'e'" "'r'"
       :itype
       :cr
       :abort
       :exit]}

{:token :csimilar
 :name "C~"
 :args [[:c1 :c2] [:f]]
 :source ": C~ ( c1 c2 -- f )  >UPPER SWAP >UPPER = ;"
 :pfa [:toupper :swap :toupper :equals :exit]}

{:token :charlit :flags #{:headerless}}

;; DIGIT? [Enforth] "digit-question" ( char -- u -1 | 0 )
;;
;; Attempts to convert char to a numeric value using the current BASE.
;; Pushes the numeric value and -1 to the stack if the value was
;; converted, otherwise pushes 0 to the stack.
{:token :digitq
 :name "DIGIT?"
 :args [[:c] [[:u -1] [0]]]
 :flags #{:headerless}
 :source ": DIGIT? ( char -- u -1 | 0)
            >UPPER [CHAR] 0 -
            DUP 0< IF DROP 0 EXIT THEN
            DUP 9 > IF DUP 16 < IF DROP FALSE EXIT ELSE 7 - THEN THEN
            DUP 1+ BASE @ > IF DROP FALSE ELSE TRUE THEN ;"
 :pfa [:toupper :icharlit "'0'" :minus
       :dup :zeroless :izbranch 4 :drop :zero :exit
       :dup :icharlit 9 :greaterthan :izbranch 13
         :dup :icharlit 17 :lessthan :izbranch 4
           :drop :false :exit
           :icharlit 7 :minus
       :dup :oneplus :base :fetch :ugreaterthan :izbranch 4
         :drop :false :exit
         :true
       :exit]}

{:token :dp
 :args [[] [:addr]]
 :flags #{:headerless}
 :source ": DP ( -- addr )  VM +DP ;"
 :pfa [:vm :icharlit "offsetof(EnforthVM, dp)" :plus :exit]}

; END-LOOP [Enforth] ( do-orig pdo-xt -- )
;
; Completes the loop whose loop-sys parameters on the stack.  pdo-xt
; points to either (loop) or (+loop) and is compiled into the end of
; the loop.
{:token :endloop
 :name "END-LOOP"
 :flags #{:headerless}
 :source ": END-LOOP ( do-orig xt )
            COMPILE,  HERE - C,  'PREVLEAVE @ HERE>CHAIN ;"
 :pfa [:compilecomma :here :minus :ccomma
       :tickprevleave :fetch :heretochain
       :exit]}

#_{:token :ffiq
 :name "FFI?"
 :args [[:xt] [:f]]
 :flags #{:headerless}
 :source ": FFI? ( xt -- f)  >DEF-TYPE kDefTypeFFI = ;"
 :pfa [:todeftype :icharlit "kDefTypeFFI" :equals :exit]}
{:token :ffiq
 :name "FFI?"
 :args [[:xt] [:f]]
 :flags #{:headerless}
 :pfa [:drop :false :exit]}

{:token :ffidefarity
 :name "FFIDEF-ARITY"
 :args [[:addr] [:u]]
 :flags #{:headerless}
 :pfa [:icharlit "offsetof(EnforthFFIDef, arity)" :plus :icfetch :exit]}

{:token :ffidefname
 :name "FFIDEF-NAME"
 :args [[:addr] [:c-addr]]
 :flags #{:headerless}
 :pfa [:icharlit "offsetof(EnforthFFIDef, name)" :plus :ifetch :exit]}

{:token :ffidefnamelen
 :name "FFIDEF-NAMELEN"
 :args [[:addr] [:u]]
 :flags #{:headerless}
 :source ": FFIDEF-NAMELEN ( addr -- u )
            FFIDEF-NAME DUP ( addr-start addr )
            BEGIN DUP IC@ WHILE 1+ REPEAT SWAP - ;"
 :pfa [:ffidefname :dup
       :dup :icfetch :izbranch 4
         :oneplus :ibranch -6
       :swap :minus
       :exit]}

{:token :ffis
 :args [[] []]
 :source ": LAST-FFIDEF ( -- addr ) 'LAST-FFIDEF ;
          : FFIS ( -- )
            LAST-FFIDEF @
            BEGIN ?DUP WHILE
              DUP FFIDEF-NAME OVER FFIDEF-NAMELEN ITYPE  SPACE
              I@
            REPEAT ;"
 :pfa [; LAST-FFIDEF
         :vm :icharlit "offsetof(EnforthVM, last_ffi)" :plus
       :fetch
       :qdup :izbranch 10
         :dup :ffidefname :over :ffidefnamelen :itype :space
         :ifetch :ibranch -11
       :exit]}

{:token :finddef
 :name "FIND-DEF"
 :args [[:caddr :u] [[0] [:xt 1] [:xt -1]]]
 :flags #{:headerless}
 :source ": IMMEDIATE-DEF? ( xt -- f )  >LFA 2 + C@ %10000000 AND 0<> ;
          : FIND-DEF ( c-addr u -- 0 | xt 1 | xt -1 )
          2>R  LATEST @
          BEGIN
            ( xt R:ca u) ?DUP
          WHILE
            DUP 2R@ ROT ( xt ca u xt R:ca u) FOUND-DEF? ( xt f R:ca u)
            IF  DUP IMMEDIATE-DEF? 2 AND 1-  2R> 2DROP  EXIT THEN
            >LFA XT@
          REPEAT ( R:ca u) 2R> 2DROP FALSE ;"
 :pfa [:twotor :latest :fetch
       :qdup :izbranch 27
         :dup :tworfetch :rot :founddefq :izbranch 17
           :dup
           ; IMMEDIATE-DEF?
             :tolfa :oneplus :oneplus :cfetch :icharlit 0x80 :and :zeronotequals
           :icharlit 2 :and :oneminus :tworfrom :twodrop :exit
         :tolfa :xtfetch
         :ibranch -28
       :tworfrom :twodrop :false
       :exit]}

{:token :findffidef
 :name "FIND-FFIDEF"
 :flags #{:headerless}
 :args [[:caddr :u] [[0] [:addr -1]]]
 :source ": LAST-FFIDEF ( -- addr ) 'LAST-FFIDEF ;
          : FIND-FFIDEF ( c-addr u -- 0 | addr -1 )
            2>R  LAST-FFIDEF @
            BEGIN ?DUP WHILE ( ffidef-addr R:ca u)
              R@ OVER FFIDEF-NAMELEN ( fda u len)
              = IF DUP 2R@ ROT ( fda ca u fda)
                FOUND-FFIDEF? IF ( fda R:ca u) 2R> 2DROP TRUE EXIT THEN THEN
              I@
            REPEAT ( R:ca u) 2R> 2DROP  FALSE ;"
 :pfa [:twotor
       ; LAST-FFIDEF
         :vm :icharlit "offsetof(EnforthVM, last_ffi)" :plus
       :fetch
       :qdup :izbranch 20
         :rfetch :over :ffidefnamelen :equals :izbranch 11
           :dup :tworfetch :rot
           :foundffidefq :izbranch 5
             :tworfrom :twodrop :true :exit
         :ifetch
         :ibranch -21
       :tworfrom :twodrop :false
       :exit]}

{:token :findprim
 :name "FIND-PRIM"
 :args [[:caddr :u] [[0] [:xt 1] [:xt -1]]]
 :flags #{:headerless}
 :source ": IMMEDIATE-PRIM? ( addr -- f ) IC@ %10000000 AND 0<> ;
          : FIND-PRIM ( c-addr u -- 0 | xt 1 | xt -1 )
            2>R  0 'NAMES
            BEGIN
              ( token namesaddr R:ca u) DUP IC@ $FF <>
            WHILE
              DUP 2R@ ROT ( t na ca u na R:ca u) FOUND-PRIM?
              IF ( t na na' R:ca u) DROP  IMMEDIATE-PRIM? 2 AND 1-
                2R> 2DROP  EXIT THEN
              ROT 1+ ( na na' t+1) ROT DROP SWAP ( t+1 na')
            REPEAT ( token na R:ca u) 2DROP 2R> 2DROP FALSE ;"
 :pfa [:twotor :zero :ticknames
       :dup :icfetch :icharlit 0xff :notequals :izbranch 27
         :dup :tworfetch :rot :foundprimq :izbranch 14
           :drop
           ; IMMEDIATE-PRIM?
             :icfetch :icharlit 0x80 :and :zeronotequals
           :icharlit 2 :and :oneminus
           :tworfrom :twodrop :exit
         :rot :oneplus :rot :drop :swap
         :ibranch -32
       :twodrop :tworfrom :twodrop :false
       :exit]}

;; FIND-WORD [Enforth] "paren-find-paren" ( c-addr u -- c-addr u 0 | xt 1 | xt -1 )
;;
;; Find the definition named in the string at c-addr with length u in
;; the word list whose latest definition is pointed to by nfa.  If the
;; definition is not found, return the string and zero.  If the
;; definition is found, return its execution token xt.  If the
;; definition is immediate, also return one (1), otherwise also return
;; minus-one (-1).  For a given string, the values returned by FIND-WORD
;; while compiling may differ from those returned while not compiling.
{:token :findword
 :name "FIND-WORD"
 :args [[:caddr :u] [[:caddr :u 0] [:xt 1] [:xt -1]]]
 :flags #{:headerless}
 :source ": FIND-WORD ( c-addr u -- c-addr u 0 | xt 1 | xt -1 )
            2DUP FIND-DEF ( ca u 0 | ca u xt 1/-1) ?DUP IF 2SWAP 2DROP
            ELSE 2DUP FIND-PRIM ( ca u 0 | ca u xt 1/-1) DUP IF 2SWAP 2DROP
            THEN ;"
 :pfa [:twodup :finddef :qdup :izbranch 5
         :twoswap :twodrop :ibranch 8
         :twodup :findprim :dup :izbranch 3
           :twoswap :twodrop
         :exit]}

;; FOUND-DEF? [Enforth] "found-def-question" ( c-addr u xt -- f)
;;
;; Compares the string c-addr with length u to the name of the
;; dictionary entry identified by xt and pushes true to the stack if the
;; names are identical (ignoring case), false otherwise.
{:token :founddefq
 :name "FOUND-DEF?"
 :args [[:caddr :u :xt] [:f]]
 :flags #{:headerless}
 :source ": HIDDEN? ( xt -- f ) >LFA 2 + C@ %01000000 AND 0<> ;
          : STRING~ ( c-addr1 c-addr2 u -- f )
            BEGIN
              ?DUP
            WHILE
              1- >R ( ca1 ca2 R:u'-1)
              OVER C@  OVER C@ C{} IF 2DROP R> DROP FALSE EXIT THEN
              1+ SWAP 1+ SWAP ( ca1' ca2' R:u'-1) R>
            REPEAT ( ca' ca2') 2DROP TRUE ;
          : FOUND-DEF? ( c-addr u xt -- f)
            DUP HIDDEN? IF DROP 2DROP FALSE EXIT THEN
            2DUP NAME-LENGTH ( ca u xt u u') <> IF DROP 2DROP FALSE EXIT THEN
            DUP FFI? IF ( ca u xt) FOUND-FFI? EXIT THEN
            >NFA ( ca u ca') SWAP STRING~ ;"
 :pfa [:dup
       ; HIDDEN
         :tolfa :oneplus :oneplus :cfetch :icharlit 0x40 :and :zeronotequals
       :izbranch 5
         :drop :twodrop :false :exit
       :twodup :namelength :notequals :izbranch 5
         :drop :twodrop :false :exit
       :dup :ffiq :izbranch 3
         :foundffiq :exit
       :tonfa :swap
       ; STRING~
         :qdup :izbranch 22
           :oneminus :tor
           :over :cfetch :over :cfetch :cnotsimilar :izbranch 6
             :twodrop :rfrom :drop :false :exit
           :oneplus :swap :oneplus :swap :rfrom
           :ibranch -23
         :twodrop :true
       :exit]}

{:token :foundffiq
 :name "FOUND-FFI?"
 :args [[:caddr :u :xt] [:f]]
 :flags #{:headerless}
 :source ": FOUND-FFI? ( c-addr u xt -- f )  >FFIDEF FOUND-FFIDEF? ;"
 :pfa [:toffidef :foundffidefq :exit]}

{:token :foundffidefq
 :name "FOUND-FFIDEF?"
 :args [[:caddr :u :addr] [:f]]
 :flags #{:headerless}
 :source ": FOUND-FFIDEF? ( c-addr u addr -- f )
            FFIDEF-NAME SWAP ( c-addr c-addrffi u)
            BEGIN
              ?DUP
            WHILE
              1- >R ( ca caffi R:u'-1)
              OVER C@  OVER IC@ C{} IF 2DROP R> DROP FALSE EXIT THEN
              1+ SWAP 1+ SWAP ( ca' caffi' R:u'-1) R>
            REPEAT ( ca' caffi') 2DROP TRUE ;"
 :pfa [:ffidefname :swap
       :qdup :izbranch 22
         :oneminus :tor
         :over :cfetch :over :icfetch :cnotsimilar :izbranch 6
           :twodrop :rfrom :drop :false :exit
         :oneplus :swap :oneplus :swap :rfrom :ibranch -23
        :twodrop :true
        :exit]}

{:token :foundprimq
 :name "FOUND-PRIM?"
 :args [[:caddr :u :offset1] [:offset2 :f]]
 :flags #{:headerless}
 :source ": PRIM-NAMELEN ( addr -- u )  IC@ $3F AND ;
          : TRAVERSE-PRIM-NAME ( addr1 -- addr2 )  DUP PRIM-NAME-LENGTH + 1+ ;
          : FOUND-PRIM? ( c-addr u addr1 -- addr2 f )
            DUP TRAVERSE-PRIM-NAME >R ( ca u addr1 R:addr2)
            DUP PRIM-NAME-LENGTH ROT <> IF 2DROP R> FALSE EXIT THEN
            1+ BEGIN ( ca addr1+1 R:addr2)
              OVER C@  OVER IC@ C{} IF 2DROP R> FALSE EXIT THEN
              1+ SWAP 1+ SWAP ( ca' addr' R:addr2)
              DUP R@ =
            UNTIL
            ( ca' off' R:off2) 2DROP R> TRUE ;"
 :pfa [:dup
       ; TRAVERSE-PRIM-NAME
         :dup
         ; PRIM-NAMELEN
           :icfetch :icharlit 0x3F :and
         :plus :oneplus
       :tor
       :dup
       ; PRIM-NAME-LENGTH
         :icfetch :icharlit 0x3F :and
       :rot :notequals :izbranch 5
           :twodrop :rfrom :false :exit
       :oneplus
         :over :cfetch :over :icfetch :cnotsimilar :izbranch 5
           :twodrop :rfrom :false :exit
         :oneplus :swap :oneplus :swap
         :dup :rfetch :equals :izbranch -19
         :twodrop :rfrom :true
       :exit]}

{:token :halt
 :flags #{:headerless}
 :source ": HALT ( i*x -- )  (HALT) ;"
 :pfa [:phalt :exit]}

; HERE>CHAIN [Enforth] "here-to-chain" ( addr -- )
;
; Store the offset to HERE in the zero-terminated chain beginning at
; addr.  Each addr is expected to contain the offset to the addr of the
; previous element in the chain.  The last element in the chain (which
; could be the initial addr if no LEAVE was present) should contain
; zero.
;
; The way that this works is that DO stores zero in 'PREVLEAVE.  The
; first LEAVE compiles a (BRANCH) token and the current contents of
; 'PREVLEAVE, which is zero.  'PREVLEAVE is then updated to contain the
; HERE location of the branch address.
;
; Subsequent LEAVEs compile a backwards (BRANCH) from HERE to the
; previous LEAVE branch (hence 'PREVLEAVE).  'PREVLEAVE is then updated
; to contain the address of the latest backwards branch.
;
; HERE>CHAIN starts at the latest 'PREVLEAVE, sets aside the branch
; value at that location, and then replaces that value with the relative
; forward offset to HERE.  We're done if the previous backwards branch
; value was zero, otherwise we use that value to find the previous LEAVE
; and repeat this same process.
{:token :heretochain
 :name "HERE>CHAIN"
 :args [[:addr] []]
 :flags #{:headerless}
 :source ": HERE>CHAIN ( prev-leave-addr -- )
            BEGIN
              ?DUP
            WHILE
              DUP C@ ( prev-leave-addr offset-to-prev-leave)
              OVER ( pla otpl pla) DUP HERE SWAP - ( pla otpl pla pla>here)
              SWAP C! ( pla otpl)
              ?DUP IF - ELSE ( pla) DROP 0 THEN
            REPEAT ;"
 :pfa [:qdup :izbranch 20
         :dup :cfetch
         :over :dup :here :swap :minus
         :swap :cstore
         :qdup :izbranch 4
           :minus :ibranch 3
           :drop :zero
         :ibranch -21
       :exit]}

{:token :hide
 :args [[] []]
 :flags #{:headerless}
 :source ": HIDE ( --)
            LATEST @ >LFA 2 +
            ( addr) DUP C@ %01000000 OR ( addr val)
            ( addr val) SWAP C!"
 :pfa [:latest :fetch :tolfa :oneplus :oneplus
       :dup :cfetch :icharlit 0x40 :or
       :swap :cstore
       :exit]}

{:token :hld
 :args [[] [:aaddr]]
 :flags #{:headerless}
 :pfa [:vm :icharlit "offsetof(EnforthVM, hld)" :plus :exit]}

{:token :hldend
 :args [[] [:c]]
 :flags #{:headerless}
 :source ": HLDEND ( -- u)  [ 1 CELLS 8 * 3 * ] ;"
 :pfa [:icharlit "kEnforthCellSize * 8 * 3" :exit]}

{:token :ibranch
 :args [[] []]
 :flags #{:headerless}}

{:token :icfetch
 :name "IC@"
 :args [[:c-addr] [:c]]
 :flags #{:headerless}}

{:token :icharlit
 :flags #{:headerless}
 :args [[] [:char]]}

{:token :ifetch
 :name "I@"
 :args [[:addr] [:x]]
 :flags #{:headerless}}

{:token :initrp :flags #{:headerless}}

{:token :interpret
 :args [[:caddr :u] []]
 :flags #{:headerless}
 :source ": INTERPRET ( i*x c-addr u -- j*x )
            'SOURCELEN 2!  0 >IN !
            BEGIN  BL PARSE-WORD  DUP WHILE
              FIND-WORD ( ca u 0=notfound | xt 1=imm | xt -1=interp)
              ?DUP IF ( xt 1=imm | xt -1=interp)
                1+  STATE @ 0=  OR ( xt 2=imm | xt 0=interp)
                IF EXECUTE ELSE COMPILE, THEN
              ELSE
                NUMBER? IF
                  STATE @ IF POSTPONE LITERAL THEN
                  -- Interpreting; leave number on stack.
                ELSE
                  TYPE  SPACE  [CHAR] ? EMIT  CR  ABORT
                THEN
              THEN
            REPEAT ( j*x ca u) 2DROP ;"
 :pfa [:vm :icharlit "offsetof(EnforthVM, source_len)" :plus :twostore
       :zero :toin :store
         :bl :parseword :dup :izbranch 37
           :findword :qdup :izbranch 14
             :oneplus :state :fetch :zeroequals :or :izbranch 4
             :execute :ibranch 21
             :compilecomma :ibranch 18
           :numberq :izbranch 8
             :state :fetch :izbranch 11
               :literal :ibranch 8
             :type :space :icharlit "'?'" :emit :cr :abort
           :ibranch -40
       :twodrop
       :exit]}

{:token :itype
 :args [[:icaddr :u] []]
 :flags #{:headerless}
 :source ": ITYPE ( ic-addr u -- )
            OVER + SWAP ( caend ca)
            BEGIN 2DUP <> WHILE DUP IC@ EMIT  1+ REPEAT 2DROP ;"
 :pfa [:over :plus :swap
       :twodup :notequals :izbranch 7
         :dup :icfetch :emit :oneplus :ibranch -9
       :twodrop
       :exit]}

{:token :izbranch
 :args [[] []]
 :flags #{:headerless}}

{:token :latest
 :args [[] [:aaadr]]
 :pfa [:vm :icharlit "offsetof(EnforthVM, latest)" :plus :exit]}

{:token :lit
 :name "(LIT)"
 :args [[] [:x]]
 :flags #{:headerless}}

;; Length of the definition name, not necessarily the NFA field (because
;; FFI trampolines have a zero-length NFA since the name is stored in
;; ROM in the FFI definition).
{:token :namelength
 :name "NAME-LENGTH"
 :args [[:xt] [:u]]
 :flags #{:headerless}
 :source ": NAME-LENGTH ( xt -- ru)  >LFA 2 + C@ $3F AND ;"
 :pfa [:tolfa :oneplus :oneplus :cfetch :icharlit 0x3F :and :exit]}

;; Length of the NFA field, not necessarily the name itself (because FFI
;; trampolines have a zero-length NFA since the name is stored in ROM in
;; the FFI definition).
{:token :nfalength
 :name "NFA-LENGTH"
 :args [[:xt] [:u]]
 :flags #{:headerless}
 :source ": NFA-LENGTH ( xt -- ru)
            DUP FFI? IF DROP 0 ELSE NAME-LENGTH THEN ;"
 :pfa [:dup :ffiq :izbranch 5
         :drop :zero :ibranch 2
         :namelength
       :exit]}

;; NUMBER? [ENFORTH] "number-question" ( c-addr u -- c-addr u 0 | n -1 )
;;
;; Attempt to convert a string at c-addr of length u into digits, using
;; the radix in BASE.  The number and -1 is returned if the conversion
;; was successful, otherwise 0 is returned.
{:token :numberq
 :name "NUMBER?"
 :args [[:caddr :u] [[:caddr :u 0] [:n -1]]]
 :flags #{:headerless}
 :source ": SIGN? ( ca1 u1 -- ca2 u2 f )
            OVER  C@  DUP [CHAR] - =  OVER [CHAR] + = OR  IF
                [CHAR] - = IF -1 ELSE 0 THEN  >R 1 /STRING R>
            ELSE DROP 0 THEN ;
          : ?NEGATE ( n1 n2 -- n3)   0< IF NEGATE THEN ;
          : NUMBER? ( c-addr u -- c-addr u 0 | n -1)
            SIGN? >R  2DUP 0 0 2SWAP  >NUMBER  ( ca u ud ca2 u2)
            IF DROP 2DROP  R> DROP  0 ELSE
               DROP 2NIP DROP  R> ?NEGATE  -1 THEN ;"
 :pfa [; SIGN?
         :over :cfetch :dup :icharlit "'-'" :equals
         :over :icharlit "'+'" :equals :or :izbranch 17
           :icharlit "'-'" :equals :izbranch 4
             :true :ibranch 2
             :false
           :tor :icharlit 1 :slashstring :rfrom :ibranch 3
           :drop :zero
       :tor :twodup :zero :zero :twoswap :tonumber :izbranch 8
         :drop :twodrop :rfrom :drop :zero :ibranch 10
         :drop :twonip :drop :rfrom
         ; ?NEGATE
           :zeroless :izbranch 2 :negate
         :true
       :exit]}

;; PARSE-WORD [Enforth] "parse-word" ( char "ccc<char>" -- c-addr u )
;;
;; Parse ccc delimited by the delimiter char, skipping leading
;; delimiters.
;;
;; c-addr is the address (within the input buffer) and u is the length
;; of the parsed string.  If the parse area was empty, the resulting
;; string has a zero length.
;;
;; Note that PARSE-WORD returns the length of the string between the
;; found delimiters (or until the end of the parse area), but advances
;; >IN past the final delimiter (unless we hit the end of the parse area
;; without finding a delimiter).
{:token :parseword
 :name "PARSE-WORD"
 :args [[:c] [:caddr :u]]
 :source ": SKIP-DELIM ( c-addr1 u1 c -- c-addr2 u2)
            >R  BEGIN  OVER C@  R@ =  ( ca u f R:c) OVER  AND WHILE
               1 /STRING REPEAT  R> DROP ;
          : FIND-DELIM ( c-addr u c -- c-addr-delim -1 | c-addr-end 0)
            >R
            BEGIN ( ca u R:c)
              DUP 0= IF R> 2DROP FALSE EXIT
              OVER C@ R@ = IF R> 2DROP TRUE EXIT
              1 /STRING
            AGAIN ;
          : PARSE-WORD ( c -- c-addr u)
            >R  SOURCE >IN @ /STRING ( ca-parse u-parse R:c)
            R@ SKIP-DELIM ( ca u R:c)  OVER SWAP ( ca-word ca-word u R:c)
            R> FIND-DELIM ( ca-word ca-delim-or-end found-delim?)
            OVER SOURCE DROP ( caw cad found-delim? cad cas) -
            SWAP IF 1+ ( advance past delim) THEN  >IN ! ( caw cad)
            OVER - ;"
 :pfa [:tor :source :toin :fetch :slashstring
       :rfetch
         ; SKIP-DELIM
         :tor
         :over :cfetch :rfetch :equals :over :and :izbranch 6
           :icharlit 1 :slashstring :ibranch -12
         :rfrom :drop
       :over :swap
       :rfrom
         ; FIND-DELIM
         :tor
           :dup :zeroequals :izbranch 6
             :rfrom :twodrop :false :ibranch 17
           :over :cfetch :rfetch :equals :izbranch 6
             :rfrom :twodrop :true :ibranch 6
           :icharlit 1 :slashstring :ibranch -24
       :over :source :drop :minus
       :swap :izbranch 2
         :oneplus
       :toin :store
       :over :minus
       :exit]}

; (DO) [Enforth] "paren-do-paren" ( n1|u1 n2|u2 -- ) ( R: -- loop-sys )
;
; Set up loop control parameters with index n2|u2 and limit n1|u1. An
; ambiguous condition exists if n1|u1 and n2|u2 are not both the same
; type.  Anything already on the return stack becomes unavailable until
; the loop-control parameters are discarded.
{:token :pdo
 :name "(DO)"
 :args [[:n1 :n2] []]
 :flags #{:headerless}}

{:token :pexecute :name "(EXECUTE)" :flags #{:headerless}}

{:token :phalt :flags #{:headerless}}

{:token :piqdo
 :name "(I?DO)"
 :flags #{:headerless}}

{:token :piloop
 :name "(ILOOP)"
 :flags #{:headerless}}

{:token :piplusloop
 :name "(I+LOOP)"
 :flags #{:headerless}}

{:token :pisquote
 :name "(IS\")"
 :args [[] [:icaddr :u]]
 :flags #{:headerless}}

; (LOOP) [Enforth] "paren-loop-paren" ( -- ) ( R: loop-sys1 -- | loop-sys2 )
;
; An ambiguous condition exists if the loop control parameters are
; unavailable.  Add one to the loop index.  If the loop index is then
; equal to the loop limit, discard the loop parameters and continue
; execution immediately following the loop.  Otherwise continue
; execution at the beginning of the loop.
{:token :ploop
 :name "(LOOP)"
 :flags #{:headerless}}

{:token :pplusloop
 :name "(+LOOP)"
 :flags #{:headerless}}

{:token :pqdo
 :name "(?DO)"
 :flags #{:headerless}}

{:token :psquote :name "(S\")" :flags #{:headerless}}

;; TODO Move to double.edn as part of cleaning up this file.
{:token :qdnegate
 :name "?DNEGATE"
 :args [[:d1 :n] [:d2]]
 :flags #{:headerless}
 :source ": ?DNEGATE ( d1 n -- d2)   0< IF DNEGATE THEN ;"
 :pfa [:zeroless :izbranch 2 :dnegate :exit]}

{:token :qnegate
 :name "?NEGATE"
 :args [[:n1 :n2] [:n3]]
 :flags #{:headerless}
 :source ": ?NEGATE ( n1 n2 -- n3)   0< IF NEGATE THEN ;"
 :pfa [:zeroless :izbranch 2 :negate :exit]}

{:token :reveal
 :args [[] []]
 :flags #{:headerless}
 :source ": REVEAL ( --)
            LATEST @ >LFA 2 +
            ( addr) DUP C@ %10111111 AND ( addr val)
            ( addr val) SWAP C!"
 :pfa [:latest :fetch :tolfa :oneplus :oneplus
       :dup :cfetch :icharlit 0xBF :and
       :swap :cstore
       :exit]}

{:token :tib
 :args [[] [:caadr]]
 :flags #{:headerless}
 :pfa [:vm :icharlit "offsetof(EnforthVM, tib)" :plus :exit]}

;; TODO Put TIBSIZE in a constant.
{:token :tibsize
 :args [[] [:u]]
 :flags #{:headerless}
 :pfa [:icharlit 80 :exit]}

{:token :ticknames
 :name "'NAMES"
 :args [[] [:c-addr]]
 :flags #{:headerless}}

{:token :tickprevleave
 :name "'PREVLEAVE"
 :flags #{:headerless}
 :pfa [:vm :icharlit "offsetof(EnforthVM, prev_leave)" :plus :exit]}

;; xt must refer to a compiled (not primitive) definition or FFI
;; trampoline.
{:token :tocfa
 :name ">CFA"
 :args [[:xt] [:addr]]
 :flags #{:headerless}
 :source ": >CFA ( xt -- addr)  DUP NFA-LENGTH  SWAP >LFA 2 + 1+  + ;"
 :pfa [:dup :nfalength :swap :tolfa :oneplus :oneplus :oneplus :plus :exit]}

{:token :toffidef
 :name ">FFIDEF"
 :args [[:xt] [:addr]]
 :flags #{:headerless}
 :source ": >FFIDEF ( xt -- addr ) >BODY @ ;"
 :pfa [:tobody :fetch :exit]}

{:token :tokenq
 :name "TOKEN?"
 :flags #{:headerless}
 :source ": TOKEN? ( xt -- f)  XTFLAG AND 0= ;"
 :pfa [:xtflag :and :zeroequals :exit]}

;; xt must refer to a compiled (not primitive) definition or FFI
;; trampoline.
{:token :tolfa
 :name ">LFA"
 :args [[:xt] [:a-addr]]
 :flags #{:headerless}
 :source ": >LFA ( xt -- a-addr)  XTMASK AND 'DICT + ;"
 :pfa [:xtmask :and
       ; 'DICT
         :vm :icharlit "offsetof(EnforthVM, dictionary)" :plus :fetch
       :plus
       :exit]}

{:token :tonfa
 :name ">NFA"
 :args [[:xt] [:c-addr]]
 :flags #{:headerless}
 :source ": >NFA ( xt -- c-addr )  >LFA 2 + 1+ ;"
 :pfa [:tolfa :oneplus :oneplus :oneplus :exit]}

;; >TOKEN [ENFORTH] "to-token" ( xt -- token )
;;
;; Return the execution token for the given XT, which may refer to a
;; token, user definition, or FFI trampoline.
{:token :totoken
 :name ">TOKEN"
 :args [[:xt] [:token]]
 :flags #{:headerless}
 :source ": >TOKEN ( xt -- token)
            DUP TOKEN? IF EXIT THEN
            DUP FFI? IF >FFIDEF FFIDEF-ARITY FFI-EXECUTION-TOKEN-BASE +
            ELSE >CFA C@ THEN ;"
 :pfa [:dup :tokenq :izbranch 2 :exit
       :dup :ffiq :izbranch 8
         :toffidef :ffidefarity :icharlit 0xf8 :plus :ibranch 3
         :tocfa :cfetch
       :exit]}

{:token :toupper
 :name ">UPPER"
 :args [[:c] [:c]]
 :source ": >UPPER ( c -- c )
            DUP [CHAR] a 1- > ( c f)
            OVER z 1+ < (c f f)
            AND IF 0x20 - THEN ;"
 :pfa [:dup :icharlit "'a'" :oneminus :greaterthan
       :over :icharlit "'z'" :oneplus :lessthan
       :and :izbranch 4
         :icharlit 0x20 :minus
       :exit]}

{:token :toxt
 :name ">XT"
 :args [[:a-addr] [:xt]]
 :flags #{:headerless}
 :source ": >XT ( a-addr -- xt)  'DICT - XTFLAG OR ;"
 :pfa [:vm :icharlit "offsetof(EnforthVM, dictionary)" :plus :fetch
       :minus :xtflag :or
       :exit]}

{:token :twonip
 :name "2NIP"
 :args [[:x1 :x2 :x3 :x4] [:x3 :x4]]}

{:token :uddot
 :name "UD."
 :args [[:ud] []]
 :source ": UD. ( ud -- )   <# #S #> TYPE SPACE ;"
 :pfa [:lessnumsign :numsigns :numsigngrtr :type :space :exit]}

{:token :udslashmod
 :name "UD/MOD"
 :args [[:ud1 :u1] [:n :ud2]]
 :flags #{:headerless}
 :source ": UD/MOD ( ud1 u1 -- n ud2 )   >R 0 R@ UM/MOD  R> SWAP >R UM/MOD R> ;"
 :pfa [:tor :zero :rfetch :umslashmod
       :rfrom :swap :tor :umslashmod :rfrom
       :exit]}

;; TODO Why does this abort if given an empty USE: declaration?  It
;; should generate an error or something.
#_{:token :use
 :name "USE:"
 :args [[] []]
 :source ": USE: ( \"<spaces>name\" -- )
            BL PARSE-WORD  DUP 0= IF ABORT THEN ( ca u)
            2DUP FIND-FFIDEF ( ca u 0 | ca u addr -1)
            0= IF TYPE  SPACE  [CHAR] ? EMIT  CR  ABORT THEN ( ca u addr)
            HERE >XT  LATEST @ XT,  LATEST ! ( ca u addr)
            SWAP 3 LSHIFT kDefTypeFFI OR C,  ( ca addr)
            ALIGN ,  DROP ;"
 :pfa [:bl :parseword :dup :zeroequals :izbranch 2 :abort
       :twodup :findffidef :zeroequals :izbranch 8
         :type :space :icharlit "'?'" :emit :cr :abort
       :here :toxt :latest :fetch :xtcomma :latest :store
       :swap :icharlit 3 :lshift :icharlit "kDefTypeFFI" :or :ccomma
       :align :comma :drop
       :exit]}

{:token :vm
 :args [[] [:addr]]
 :flags #{:headerless}}

{:token :xtcomma
 :name "XT,"
 :args [[:xt] []]
 :flags #{:headerless}
 :source ": XT, ( xt -- )  DUP C,  8 RSHIFT C, ;"
 :pfa [:dup :ccomma :icharlit 8 :rshift :ccomma :exit]}

{:token :xtfetch
 :name "XT@"
 :args [[:addr] [:xt]]
 :flags #{:headerless}
 :source ": XT@ ( addr -- xt )  DUP C@  SWAP 1+ C@ 8 LSHIFT  OR ;"
 :pfa [:dup :cfetch :swap :oneplus :cfetch :icharlit 8 :lshift :or :exit]}

{:token :xtflag
 :args [[] [:u]]
 :flags #{:headerless}
 :pfa [:icharlit 0x80 :icharlit 8 :lshift :exit]}

{:token :xtmask
 :args [[] [:u]]
 :flags #{:headerless}
 :pfa [:icharlit 0xff :icharlit 0x7f :icharlit 8 :lshift :or :exit]}

{:token :zbranch :name "0BRANCH" :flags #{:headerless}}

{:token :zero :name "0"}
