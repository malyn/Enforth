{:token :branch :flags #{:headerless}}

{:token :cfetchnames
 :name "C@NAMES"
 :args [[:u] [:c]]
 :flags #{:headerless}}

{:token :changelatestdeftype
 :name "CHANGE-LATEST-DEF-TYPE"
 :args [[:u] []]
 :flags #{:headerless}
 :source ": CHANGE-LATEST-DEF-TYPE ( u --)
            LATEST @ >LFA 2 +  C@ %11111000 AND  OR
            LATEST @ >LFA 2 +  C!"
 :pfa [:latest :fetch :tolfa :oneplus :oneplus :cfetch :charlit 0xF8 :and
       :or :latest :fetch :tolfa :oneplus :oneplus :cstore
       :exit]}

{:token :charlit :flags #{:headerless}}

{:token :cplusstore :name "C+!"}

;; DIGIT? [MFORTH] "digit-question" ( char -- u -1 | 0 )
;;
;; Attempts to convert char to a numeric value using the current BASE.
;; Pushes the numeric value and -1 to the stack if the value was
;; converted, otherwise pushes 0 to the stack.
{:token :digitq
 :name "DIGIT?"
 :args [[:c] [[:u -1] [0]]]
 :flags #{:headerless}
 :source ": DIGIT? ( char -- u -1 | 0)
            [CHAR] 0 -
            DUP 0< IF DROP 0 EXIT THEN
            DUP 9 > IF DUP 16 < IF DROP FALSE EXIT ELSE 7 - THEN THEN
            DUP 1+ BASE @ > IF DROP FALSE ELSE TRUE THEN ;"
 :pfa [:charlit "'0'" :minus
       :dup :zeroless :zbranch 4 :drop :zero :exit
       :dup :charlit 9 :greaterthan :zbranch 13
         :dup :charlit 17 :lessthan :zbranch 4
           :drop :false :exit
           :charlit 7 :minus
       :dup :oneplus :base :fetch :ugreaterthan :zbranch 4
         :drop :false :exit
         :true
       :exit]}

{:token :exit :flags #{:headerless}}

{:token :ffiq
 :name "FFI?"
 :args [[:xt] [:f]]
 :flags #{:headerless}
 :source ": FFI? ( xt -- f)  >DEF-TYPE kDefTypeFFI = ;"
 :pfa [:todeftype :charlit "kDefTypeFFI" :equals :exit]}

{:token :ffiarity
 :name "FFI-ARITY"
 :args [[:xt] [:u]]
 :flags #{:headerless}}

{:token :finddef
 :name "FIND-DEF"
 :args [[:caddr :u] [[0] [:xt 1] [:xt -1]]]
 :flags #{:headerless}
 :source ": IMMEDIATE-DEF? ( xt -- f ) >DEF-TYPE kDefTypeCOLONIMMEDIATE = ;
          : FIND-DEF ( c-addr u -- 0 | xt 1 | xt -1 )
          2>R  LATEST @
          BEGIN
            ( xt R:ca u) ?DUP
          WHILE
            DUP 2R@ ROT ( xt ca u xt R:ca u) FOUND-DEF? ( xt f R:ca u)
            IF  DUP IMMEDIATE-DEF? 2 AND 1-  2R> 2DROP  EXIT THEN
            >LFA W@
          REPEAT ( R:ca u) 2R> 2DROP FALSE ;"
 :pfa [:twotor :latest :fetch
       :qdup :zbranch 23
         :dup :tworfetch :rot :founddefq :zbranch 13
           :dup
           ; IMMEDIATE-DEF?
             :todeftype :charlit "kDefTypeCOLONIMMEDIATE" :equals
           :charlit 2 :and :oneminus :tworfrom :twodrop :exit
         :tolfa :wfetch
         :branch -24
       :tworfrom :twodrop :false
       :exit]}

{:token :findprim
 :name "FIND-PRIM"
 :args [[:caddr :u] [[0] [:xt 1] [:xt -1]]]
 :flags #{:headerless}
 :source ": IMMEDIATE-PRIM? ( off -- f ) C@NAMES $7 AND kDefTypeCOLONIMMEDIATE = ;
          : FIND-PRIM ( c-addr u -- 0 | xt 1 | xt -1 )
            2>R  0 0
            BEGIN
              ( token offset R:ca u) DUP C@NAMES $FF <>
            WHILE
              DUP 2R@ ROT ( t off ca u off R:ca u) FOUND-PRIM?
              IF ( t off off2 R:ca u) DROP  IMMEDIATE-PRIM? 2 AND 1-
                2R> 2DROP  EXIT THEN
              ROT 1+ ( off off2 t+1) ROT DROP SWAP ( t+1 off2)
            REPEAT ( token offset R:ca u) 2DROP 2R> 2DROP FALSE ;"
 :pfa [:twotor :zero :zero
       :dup :cfetchnames :charlit 0xff :notequals :zbranch 27
         :dup :tworfetch :rot :foundprimq :zbranch 14
           :drop
           ; IMMEDIATE-PRIM?
           ;; TODO Change DefGen so that primitive flags are the same as def flags
           ;;:cfetchnames :charlit 0x07 :and "kDefTypeCOLONIMMEDIATE" :equals
             :cfetchnames :charlit 0x80 :and :zeronotequals
           :charlit 2 :and :oneminus
           :tworfrom :twodrop :exit
         :rot :oneplus :rot :drop :swap
         :branch -32
       :twodrop :tworfrom :twodrop :false
       :exit]}

;; FIND-WORD [Enforth] "paren-find-paren" ( c-addr u -- c-addr u 0 | xt 1 | xt -1 )
;;
;; Find the definition named in the string at c-addr with length u in
;; the word list whose latest definition is pointed to by nfa.  If the
;; definition is not found, return the string and zero.  If the
;; definition is found, return its execution token xt.  If the
;; definition is immediate, also return one (1), otherwise also return
;; minus-one (-1).  For a given string, the values returned by FIND-WORD
;; while compiling may differ from those returned while not compiling.
{:token :findword
 :name "FIND-WORD"
 :args [[:caddr :u] [[:caddr :u 0] [:xt 1] [:xt -1]]]
 :flags #{:headerless}
 :source ": FIND-WORD ( c-addr u -- c-addr u 0 | xt 1 | xt -1 )
            2DUP FIND-DEF ( ca u 0 | ca u xt 1/-1) ?DUP IF 2SWAP 2DROP
            ELSE 2DUP FIND-PRIM ( ca u 0 | ca u xt 1/-1) DUP IF 2SWAP 2DROP
            THEN ;"
 :pfa [:twodup :finddef :qdup :zbranch 5
         :twoswap :twodrop :branch 8
         :twodup :findprim :dup :zbranch 3
           :twoswap :twodrop
         :exit]}

;; FOUND-DEF? [Enforth] "found-def-question" ( c-addr u xt -- f)
;;
;; Compares the string c-addr with length u to the name of the
;; dictionary entry identified by xt and pushes true to the stack if the
;; names are identical (ignoring case), false otherwise.
;; TODO Consider dropping the early length compare and let ICOMPARE deal
;; with that.
;; TODO Probably get rid of ICOMPARE altogether and just make the
;; equivalent of IEQUALS (or even just manual compare like what is in
;; FOUND-PRIM?).
;; TODO Implement FFI support (which requires us to compare ROM strings
;; in the same manner as we'll need to compare token names, ideally with
;; exactly the same function).  Note that both FFI and token name
;; support will need the C@DEFS word.
{:token :founddefq
 :name "FOUND-DEF?"
 :args [[:caddr :u :xt] [:f]]
 :flags #{:headerless}
 :source ": HIDDEN? ( xt -- f ) >DEF-TYPE kDefTypeCOLONHIDDEN = ;
          : FOUND-DEF? ( c-addr u xt -- f)
            DUP HIDDEN? IF DROP 2DROP FALSE EXIT THEN
            2DUP NAME-LENGTH ( ca u xt u u') <> IF DROP 2DROP FALSE EXIT THEN
            DUP FFI? IF ( TODO implement this) DROP 2DROP FALSE EXIT THEN
            >LFA 2 + 1+ ( ca u ca') OVER ICOMPARE 0= ;"
 :pfa [:dup
       ; HIDDEN
         :todeftype :charlit "kDefTypeCOLONHIDDEN" :equals
       :zbranch 5
         :drop :twodrop :false :exit
       :twodup :namelength :notequals :zbranch 5
         :drop :twodrop :false :exit
       :dup :ffiq :zbranch 5
         :drop :twodrop :false :exit ;; TODO Implement this
       :tolfa :oneplus :oneplus :oneplus :over :icompare :zeroequals
       :exit]}

;; TODO Add case-insensitive compares
{:token :foundprimq
 :name "FOUND-PRIM?"
 :args [[:caddr :u :offset1] [:offset2 :f]]
 :flags #{:headerless}
 :source ": PRIM-NAME-LENGTH ( off -- u )  C@NAMES 3 RSHIFT ;
          : TRAVERSE-PRIM-NAME ( off1 -- off2 )  DUP PRIM-NAME-LENGTH + 1+ ;
          : FOUND-PRIM? ( c-addr u off1 -- off2 f )
            DUP TRAVERSE-PRIM-NAME >R ( ca u off1 R:off2)
            DUP PRIM-NAME-LENGTH ROT <> IF 2DROP R> FALSE EXIT THEN
            1+ BEGIN ( ca off1+1 R:off2)
              OVER C@  OVER C@NAMES <> IF 2DROP R> FALSE EXIT THEN
              1+ SWAP 1+ SWAP ( ca' off' R:off2)
              DUP R@ =
            UNTIL
            ( ca' off' R:off2) 2DROP R> TRUE ;"
 :pfa [:dup
       ; TRAVERSE-PRIM-NAME
         :dup
         ; PRIM-NAME-LENGTH
           ;; TODO Change DefGen so that primitive flags are the same as def flags
           ;;:cfetchnames :charlit 3 :rshift
           :cfetchnames :charlit 0x7f :and
         :plus :oneplus
       :tor
       :dup
       ; PRIM-NAME-LENGTH
         ;; TODO Change DefGen so that primitive flags are the same as def flags
         ;;:cfetchnames :charlit 3 :rshift
         :cfetchnames :charlit 0x7f :and
       :rot :notequals :zbranch 5
           :twodrop :rfrom :false :exit
       :oneplus
         :over :cfetch :over :cfetchnames :notequals :zbranch 5
           :twodrop :rfrom :false :exit
         :oneplus :swap :oneplus :swap
         :dup :rfetch :equals :zbranch -19
         :twodrop :rfrom :true
       :exit]}

{:token :hld
 :args [[] [:aaddr]]
 :flags #{:headerless}
 :pfa [:vmaddrlit "offsetof(EnforthVM, hld)" :exit]}

{:token :hldend
 :args [[] [:c]]
 :flags #{:headerless}
 :source ": HLDEND ( -- u)  [ 1 CELLS 8 * 3 * ] ;"
 :pfa [:charlit "kEnforthCellSize * 8 * 3" :exit]}

{:token :icompare
 :args [[:ca1 :u1 :ca2 :u2] [:n]]}

{:token :initrp :flags #{:headerless}}

{:token :interpret
 :args [[:caddr :u] []]
 :flags #{:headerless}
 :source ": INTERPRET ( i*x c-addr u -- j*x )
            'SOURCELEN 2!  0 >IN !
            BEGIN  BL PARSE-WORD  DUP WHILE
              FIND-WORD ( ca u 0=notfound | xt 1=imm | xt -1=interp)
              ?DUP IF ( xt 1=imm | xt -1=interp)
                1+  STATE @ 0=  OR ( xt 2=imm | xt 0=interp)
                IF EXECUTE ELSE COMPILE, THEN
              ELSE
                NUMBER? IF
                  STATE @ IF POSTPONE LITERAL THEN
                  -- Interpreting; leave number on stack.
                ELSE
                  TYPE  SPACE  [CHAR] ? EMIT  CR  ABORT
                THEN
              THEN
            REPEAT ( j*x ca u) 2DROP ;"
 :pfa [:vmaddrlit "offsetof(EnforthVM, source_len)" :twostore
       :zero :toin :store
         :bl :parseword :dup :zbranch 37
           :findword :qdup :zbranch 14
             :oneplus :state :fetch :zeroequals :or :zbranch 4
             :execute :branch 21
             :compilecomma :branch 18
           :numberq :zbranch 8
             :state :fetch :zbranch 11
               :literal :branch 8
             :type :space :charlit "'?'" :emit :cr :abort
           :branch -40
       :twodrop
       :exit]}

{:token :latest
 :args [[] [:aaadr]]
 :pfa [:vmaddrlit "offsetof(EnforthVM, latest)" :exit]}

{:token :lit
 :name "(LIT)"
 :args [[] [:x]]
 :flags #{:headerless}}

;; Length of the definition name, not necessarily the NFA field (because
;; FFI trampolines have a zero-length NFA since the name is stored in
;; ROM in the FFI definition).
{:token :namelength
 :name "NAME-LENGTH"
 :args [[:xt] [:u]]
 :flags #{:headerless}
 :source ": NAME-LENGTH ( xt -- ru)  >LFA 2 + C@ 3 RSHIFT ;"
 :pfa [:tolfa :oneplus :oneplus :cfetch :charlit 3 :rshift :exit]}

;; Length of the NFA field, not necessarily the name itself (because FFI
;; trampolines have a zero-length NFA since the name is stored in ROM in
;; the FFI definition).
{:token :nfalength
 :name "NFA-LENGTH"
 :args [[:xt] [:u]]
 :flags #{:headerless}
 :source ": NFA-LENGTH ( xt -- ru)
            DUP FFI? IF DROP 0 ELSE >LFA 2 + C@ 3 RSHIFT THEN ;"
 :pfa [:dup :ffiq :zbranch 5
         :drop :zero :branch 8
         :tolfa :oneplus :oneplus :cfetch :charlit 3 :rshift
       :exit]}

;; NUMBER? [ENFORTH] "number-question" ( c-addr u -- c-addr u 0 | n -1 )
;;
;; Attempt to convert a string at c-addr of length u into digits, using
;; the radix in BASE.  The number and -1 is returned if the conversion
;; was successful, otherwise 0 is returned.
;;
;; TODO Implement this for real.
{:token :numberq
 :name "NUMBER?"
 :args [[:caddr :u] [[:caddr :u 0] [:n -1]]]
 :flags #{:headerless}
 :source ": NUMBER? ( c-addr u -- c-addr u 0 | n -1)
            0 0 2SWAP >NUMBER 2DROP DROP TRUE ;"
 :pfa [:zero :zero :twoswap :tonumber :twodrop :drop :true :exit]}

;; PARSE-WORD [MFORTH] "parse-word" ( char "ccc<char>" -- c-addr u )
;;
;; Parse ccc delimited by the delimiter char, skipping leading
;; delimiters.
;;
;; c-addr is the address (within the input buffer) and u is the length
;; of the parsed string.  If the parse area was empty, the resulting
;; string has a zero length.
{:token :parseword
 :args [[:caddr :u1 :c] [:caddr2 :u2]]
 :flags #{:headerless}
 :source ": SKIP-DELIM ( c-addr1 u1 c -- c-addr2 u2)
            >R  BEGIN  OVER C@  R@ =  ( ca u f R:c) OVER  AND WHILE
               1 /STRING REPEAT  R> DROP ;
          : FIND-DELIM ( c-addr1 u1 c -- c-addr2)
            >R  BEGIN  OVER C@  R@ <>  ( ca u f R:c) OVER  AND WHILE
               1 /STRING REPEAT  R> 2DROP ;
          : PARSE-WORD ( c -- c-addr u)
            >R  SOURCE >IN @ /STRING ( ca-parse u-parse R:c)
            R@ SKIP-DELIM ( ca u R:c)  OVER SWAP ( ca-word ca-word u R:c)
            R> FIND-DELIM ( ca-word ca-delim)
            DUP SOURCE DROP ( caw cad cad cas) - >IN ! ( caw cad)
            OVER - ;"
 :pfa [:tor :source :toin :fetch :slashstring
       :rfetch
         ; SKIP-DELIM
         :tor
         :over :cfetch :rfetch :equals :over :and :zbranch 6
           :charlit 1 :slashstring :branch -12
         :rfrom :drop
       :over :swap
       :rfrom
         ; FIND-DELIM
         :tor
           :over :cfetch :rfetch :notequals :over :and :zbranch 6
           :charlit 1 :slashstring :branch -12
         :rfrom :twodrop
       :dup :source :drop :minus :toin :store
       :over :minus
       :exit]}

{:token :pexecute :name "(EXECUTE)" :flags #{:headerless}}

{:token :pdotquote :name "(.\")" :flags #{:headerless}}

{:token :psquote :name "(s\")" :flags #{:headerless}}

{:token :tib
 :args [[] [:caadr]]
 :flags #{:headerless}
 :pfa [:vmaddrlit "offsetof(EnforthVM, tib)" :exit]}

;; TODO Put TIBSIZE in a constant.
{:token :tibsize
 :args [[] [:u]]
 :flags #{:headerless}
 :pfa [:charlit 80 :exit]}

;; xt must refer to a compiled (not primitive) definition or FFI
;; trampoline.
{:token :todeftype
 :name ">DEF-TYPE"
 :args [[:xt] [:u]]
 :flags #{:headerless}
 :source ": >DEF-TYPE ( xt -- u)  >LFA 2 + C@ $7 AND ;"
 :pfa [:tolfa :oneplus :oneplus :cfetch :charlit 0x07 :and :exit]}

{:token :tokenq
 :name "TOKEN?"
 :flags #{:headerless}
 :source ": TOKEN? ( xt -- f)  $8000 AND 0= ;"
 :pfa [:wlit 0x00 0x80 :and :zeroequals :exit]}

;; xt must refer to a compiled (not primitive) definition or FFI
;; trampoline.
{:token :tolfa
 :name ">LFA"
 :args [[:xt] [:a-addr]]
 :flags #{:headerless}
 :source ": >LFA ( xt -- a-addr)  $7FFF AND 'DICT + ;"
 :pfa [:wlit 0xff 0x7f :and
       ; 'DICT
         :vmaddrlit "offsetof(EnforthVM, dictionary)" :fetch
       :plus
       :exit]}

;; >TOKEN [ENFORTH] "to-token" ( xt -- token )
;;
;; Return the execution token for the given XT, which may refer to a
;; token, user definition, or FFI trampoline.
{:token :totoken
 :name ">TOKEN"
 :args [[:xt] [:token]]
 :flags #{:headerless}
 :source ": >TOKEN ( xt -- token)
            DUP TOKEN? IF EXIT THEN
            DUP FFI? IF FFI-ARITY FFI-EXECUTION-TOKEN-BASE +
            ELSE >DEF-TYPE EXECUTION-TOKEN-BASE + THEN ;"
 :pfa [:dup :tokenq :zbranch 2 :exit
       :dup :ffiq :zbranch 7
         :ffiarity :charlit 0xe8 :plus :branch 5
         :todeftype :charlit 0xe0 :plus
       :exit]}

;; >[TOKEN] [ENFORTH] "to-compile-token" ( xt -- token )
;;
;; Return the compilation token for the given XT, which may refer to a
;; token, user definition, or FFI trampoline.
{:token :tocompiletoken
 :name ">[TOKEN]"
 :args [[:xt] [:token]]
 :flags #{:headerless}
 :source ": >[TOKEN] ( xt -- token)
            >TOKEN  DUP EXECUTION-TOKEN-BASE 1- > IF 0x10 + THEN ;"
 :pfa [:totoken :dup :charlit "0xe0 - 1" :greaterthan :zbranch 4
         :charlit 0x10 :plus
       :exit]}

{:token :udslashmod :flags #{:headerless}}

{:token :vmaddrlit :flags #{:headerless}}

{:token :wcomma :name "W," :flags #{:headerless}}

{:token :wfetch :name "W@" :flags #{:headerless}}

{:token :wlit :flags #{:headerless}}

{:token :zbranch :name "0BRANCH" :flags #{:headerless}}

{:token :zero :name "0"}
