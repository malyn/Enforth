* The FFI primitives are tricky when faced with processors like the AVR that can have more flash than they are able to directly address.  I also am starting to think that the FFI trampolines are going to be huge wastes of RAM.  Maybe we should do some sort of macro trickery to `#define` FFI functions in as primitives?  That gets tricky on its own though (because we're now defining C functions that call the FFI functions and also have to know about the stack and stuff)...  More macro trickery there as well.  Perhaps another option would just be to call a method on the ARF object that adds the function in as an opcode.  Then we could call code at runtime to add things to a RAM list.  But now we're wasting RAM...
  * Bottom line: we really need everything about the FFI definitions in ROM, otherwise we'll blow too much RAM.  This means that macro trickery needs to be involved.  I think that we can do some sort of `BEGIN_ARF_FFI_LIST`, `#include` stuff, then `END_ARF_FFI_LIST` macro trickery, basically putting everything into an array of structs, similar to what we are doing for the ARF primitive words.  Although we couldn't get all of that into PROGMEM, so we probably need to just have an array of pointers and stripe the data through the array (string pointer, flags, function pointer).
  * This is a lot of work to support AVR processors with weird amounts of flash...
    * But it's probably not that bad.  The FFI definition array will just contain three bytes for those weird AVR variants and we'll know to use a far pointer (`uint32_t`) on that processor.
  * We may not need the trampoline words at all if we use the top 128 (or whatever) tokens for calling FFI functions.  *i.e.,* if those tokens are the index of the FFI in the FFI definition array.
    * This would provide the best RAM usage (zero) with only a slight bit of overhead on FFI calls.  We would limit ourselves to 128 (or 96 or whatever) FFI definitions, but it's kind of hard to imagine that we would need that many anyway.
* Switch the "CFA" to opcodes.  The compiler will figure out what kind of word is being compiled and put that opcode into the definition.  This trades compiler expense -- need to interrogate the target word -- for runtime efficiency -- a single jump table for everything.  XTs on the stack might be the only challenge, because those need to include both an opcode and the target.  I suppose we can use the top two bits for the opcode and the remaining 14 bits for the offset.  `COMPILE,` gets more complex, because it then has to convert that XT into a separate 8-bit opcode and 16-bit offset.
  * This change also eliminates the need to differentiate between opcodes and relative offsets, because everything is just an opcode (and then the `DO*` opcodes are followed by the offset).  The only downside is that every call to another word now takes one extra byte of RAM.  The major upside is that now we can create up to 256 opcodes instead of just 128 opcodes; that should enable us to put more stuff into ROM, which might have been necessary anyway...
    * Should probably just make DOCOLON8 and DOCOLON16 and then align PFAs to 16-bits so that DOCOLON8 can span a full -512 bytes.
    * I wonder if the expansion from 128 to 256 primitives means that we should handle FFIs as primitives instead of as trampolines that have to be compiled into the dictionary upon usage?  I can't decide if this is more or less performant than the FFI primitives...
* Fix up all of the types; sometimes we use uint8_t, sometimes we use arfInteger, etc.
* Turn `dictionary` constructor parameter into a generic `vm` parameter.  Put data stack and return stack at the end of the `vm` buffer.  Put TIB at the start of the buffer (before the dictionary, just like MFORTH).  Allow stack sizes and TIB size to be configured in the constructor.  TIB can be zero if you do not need the text interpreter.
* "Fix" stack usage so that we don't have to waste the last (31st, currently) cell on a TOS value that will never be stored there.  Should probably put the stacks at the beginning of the buffer so that we don't have the issue with sometimes reading TOS from beyond the data stack when the stack is in fact empty.  So organization is: data stack, return stack, TIB, hidden defs, dictionary.
* Implement compilation (`:`, `COMPILE,`, `;`, etc.).
* Reorganize/Clean up source files.  Maybe auto-generate opcodes so that we can avoid some of the duplication, for example.
