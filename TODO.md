* Move some of the non-critical C++ primitives over to Forth (whatever uses the least flash).
  * Create a `DOCOLONROM` jump label that we use whenever a token refers to a ROM definition (as opposed to a C++ primitive).  `DOCOLONROM` then uses the token to find the offset of the definition in a single block where these definitions are stored.  IP is set appropriately and we enter that definition.
  * Note that we do not want to use a special set of bits or something in the XT in order to identify these definitions, because then the compiled XTs for those tokens has to be 16 bits instead of 8 bits.  We want the implementation of the primitive -- C++ or Forth -- to be hidden from the user and so primitives should always be referenced by an 8-bit token.
  * Organize the opcodes for these definitions through the 8-bit opcode space so that we can multiply/shift/whatever by some value in order to convert the opcode into the offset of the definition in the block.  We can put these definitions wherever we want, so we should be able to come up with a mechanism for locating them in ROM with minimal wastage.  The goal here is to avoid needing yet another 128\*2 byte ROM lookup table for all of these definitions and instead to just be able to calculate the offset, perhaps with the rare padding byte here and there.
    * Probably we should just multiply the opcode by 4 and then organize the definitions so that they line up as naturally as possible on 4-byte boundaries.  Padding can be used where necessary, but hopefully we can minimize that.
    * Or perhaps multiply it by a prime number so that we can pack this in anywhere in space?  Something along the lines of a Golomb Ruler?  Multiplication on the AVR takes two cycles, just like two left shifts (for x4), so we might as well multiply if it gets us better packing.
* Fix the primitive/token/opcode/etc. naming issue.
* Support backspace in `ACCEPT`.
* Modify `test/mforth` to optionally take a list of files on the command line and then interpret each file in order (by just feeding the data through `KEY` for now).  This will allow us to start running the anstests.
* Reorganize/Clean up source files.  Maybe auto-generate opcodes so that we can avoid some of the duplication, for example.
  * The first pass should pack the ROM definitions as tightly as possible, which consumes tokens throughout the 8-bit token space.
  * Then we'll fill in all of the public definitions starting from the beginning of token-space.
  * All of the non-public definitions should go at the end so that they do not waste space in the primitives lookup table (which is currently what is happening due to the hand-generated table that we are using).
* Do something about absolute RAM addresses on the stack, in variables, etc.  These prevent the VM from being saved to/from storage (such as EEPROM).
  * We can't relativize everything on save, because we don't always know what we are looking at -- how do we know that a dictionary variable contains a RAM address?  We could probably relativize all addresses in the VM though and then `@`, `!`, etc. would do the adjustment as necessary (and could offer bounds-checking).  All of these addresses are VM-relative and that VM base address will probably end up being stored in a constant register pair.  Access to memory-mapped CPU resources gets messy (this is mostly an ARM problem), although we could offer special fetch and store operations for those.  Similarly, FFI interop involving addresses is now a problem because we need to convert those back and forth.
  * Note that the VM itself has quite a few absolute addresses (DP, HERE, SOURCE, etc.) and we'll need to deal with those on load/save.  Most of these have to do with the text interpreter though and we could easily just say that persistence resets the state of the text interpreter and can only be performed when *not* in compilation mode.  That would leave a very small number of pointers in the VM and those could just be serialized as part of persisting the dictionary.
* Add a single default task and move the stacks and BASE into that memory area.  No `PAUSE` yet.
  * Tasks are 32 return stack cells (64/128 bytes), 16 data stack cells (32/64 bytes), 16 user cells (32/64 bytes) for a total of 128/256 bytes per task.
    * Note that tasks go into the dictionary and not at the end!  This allows dictionaries to be resized or only partially copied to storage.
    * Need one task cell to act as a link to the previously-created task as well as a global that points to the newest task (similar to the dictionary itself).
* Consider adding [Catch](https://github.com/philsquared/Catch)-based unit tests in order to augment the anstests-based tests.  Maybe even run the test suite using Catch?
* Forth200x updates (mostly just `TIB` and `#TIB`?, although numeric prefixes look very useful).
* Add `PAUSE`, which spills the registers to global variables in `vm` and then returns from `go()` similar to what we did in Ficl.
* Add dumb exceptions that just restart the VM?
* Consider optimizing the size of `DOCOLON` references by creating "bank-switched" versions of this opcode.  This would reduce the number of times that calling a definition needs three bytes instead of just two bytes (the primary downside to dictionary-relative instead of IP-relative compilation offsets).
  * You could call `DOCOLON0` for offsets 0-511 in the dictionary, `DOCOLON1` for 512-1023, etc.  Eight of these would allow us to span 4KB of dictionary, at which point we would just fall back to absolute references.  Most (?) dictionaries probably won't be greater than 4KB anyway, and at that point you probably have plenty of RAM to blow on three-byte references.
  * `ALIGN` would actually be needed now in order to make each bank span as many bytes as possible.
  * Remember that compiled XTs can never be smaller than 16-bits anyway, so the goal here is to try and keep those XTs at 16 bits most of the time if possible.
* Consider adding `PAD`, perhaps with a configurable size.  Do not use `PAD` in the kernel though so that we can avoid making it a requirement.
* We may not need to blow 16 opcodes on the `PDO*` opcodes; instead we can just create a dedicated jump table in `EXECUTE` for those opcodes.  `EXECUTE` is almost only ever used when we are doing text interpretation, so spilling and filling registers here should be fine.
  * The only thing that this does is save us opcode space, it still uses the same amount of ROM.  This is only valuable/necessary if we are running low on opcodes.
* Since we have more free opcodes now we can probably code in some of the most frequently used FFI functions (`pinWrite` and stuff) as tokens, perhaps through compiler directives.
  * I wonder if we can find a way to predefine a set of trampolines in Flash instead of in RAM?  *i.e.,* we reserve the last 32 opcodes for precompiled trampolines and then provide a simplified way to build up that flash array.  This table-based method would actually work since it would just be a list of other addresses (which conveniently we already have thanks to the `FFIDEF_*` vars that are being used for the linked list).  This would give users a way to modify their MFORTH compile to predefine externals in a way that consumes no RAM.  You still need to define the FFIs, but you don't need to reference them at runtime.
  * This feels like a good balance between ROM and RAM: you can access any FFI at runtime if you are willing to consume memory on that (which is probably fine during development) and then you switch to a ROM-based FFI primitive once you know you'll be using an FFI a lot.  This breaks your flash, of course, but your source is unchanged (and we could make the `EXTERNAL:` word just do nothing in the case where you are trying to reference a ROM-based FFI primitive).
  * This makes the ATtiny85 possible again, because we'll just define the primitives that we care about as ROM primitives.
