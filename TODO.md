* Implement dictionary lookup.
  * First for user-defined words.
  * Then for FFI trampolines (as part of the next item).
  * We need to implement this now because we need to make sure that all of our complex stuff regarding XT handling actually works (especially as we add support for FFI trampolines).
* The FFI primitives are tricky when faced with processors like the AVR that can have more flash than they are able to directly address.  I also am starting to think that the FFI trampolines are going to be huge wastes of RAM.  Maybe we should do some sort of macro trickery to `#define` FFI functions in as primitives?  That gets tricky on its own though (because we're now defining C functions that call the FFI functions and also have to know about the stack and stuff)...  More macro trickery there as well.  Perhaps another option would just be to call a method on the ARF object that adds the function in as an opcode.  Then we could call code at runtime to add things to a RAM list.  But now we're wasting RAM...
  * Bottom line: we really need everything about the FFI definitions in ROM, otherwise we'll blow too much RAM.  This means that macro trickery needs to be involved.  I think that we can do some sort of `BEGIN_ARF_FFI_LIST`, `#include` stuff, then `END_ARF_FFI_LIST` macro trickery, basically putting everything into an array of structs, similar to what we are doing for the ARF primitive words.  Although we couldn't get all of that into PROGMEM, so we probably need to just have an array of pointers and stripe the data through the array (string pointer, flags, function pointer).
  * This is a lot of work to support AVR processors with weird amounts of flash...
    * But it's probably not that bad.  The FFI definition array will just contain three bytes for those weird AVR variants and we'll know to use a far pointer (`uint32_t`) on that processor.
  * We may not need the trampoline words at all if we use the top 128 (or whatever) tokens for calling FFI functions.  *i.e.,* if those tokens are the index of the FFI in the FFI definition array.
    * This would provide the best RAM usage (zero) with only a slight bit of overhead on FFI calls.  We would limit ourselves to 128 (or 96 or whatever) FFI definitions, but it's kind of hard to imagine that we would need that many anyway.
  * Have to do the trampoline thing since there is no efficient way to access the linked list.  This gives us an unlimited number of FFIs, which is good, but the downside is that we use up a bit of RAM (probably eight bytes or so) per FFI that we reference.
  * The only (?) solution to this problem would be to further split up the XTs: the high bit indicates that this is not a primitive.  Then the next bit tells us if this is an FFI address (absolute address of the FFI linked list entry) or a user-defined word (relative offset from the start of the dictionary).  That gives us access to an 8KB RAM dictionary on the AVR (which I suppose is OK, especially since we could align definitions to 16 bits and then have access to 16KB of dictionary...) or 8KB of FFI ROM.  The latter is the real problem, because the FFI linked list entries will be scattered everywhere and so there is no way for us to reference them with only 8KB.  Really we would prefer to have 22 bits in order to handle the big AVRs, although we can probably just force the FFI entries into "near" flash.
  * This is all a huge pain in the neck just to support large-Flash AVRs, which seem like they are already problematic for people anyway.  I suggest that we only offer two supported configurations: a 16-bit version that only really supports the 16-bit AVRs, and a 32-bit version that supports ARM, x86, etc. processors.  The world is moving to ARM anyway, so this feels like a reasonable solution.  Then we can just assume that our cells will always be big enough to store an address.
  * We might as well still consume RAM because that seems like a precious resource and will let us use very small chips.
  * OTOH, that Pinocc.io thing uses the ATmega256RFR2 chip, which of course has 256KB of RAM, but is an 8-bit AVR!  Ugh.
  * So what's the real problem here.  We need to be able to reference FFIs anywhere in Flash, but sometimes those addresses will be bigger than 16 bits (or at least need the full 16 bits).  That means that we can't put them on the stack.  So they need to be somewhere else.  We can't create a jump table in flash because that would require us to predefine the opcodes in some annoying way (we can't do PROGMEM strings inside of a PROGMEM array definition, for example).  That means that we need a linked list for FFIs and thus the FFI definitions could be anywhere in Flash (and in fact it would probably benefit us to push those into high Flash on chips with lots of flash).  So we can use dictionary-based trampolines to use standard XTs (which we already need to support anyway), but then we're sucking up RAM for each FFI that is used.  Trampolines are going to be a 16-bit link field, two flag bytes, a 2/3 byte FFI pointer (we'll just look up the FFI name through the pointer), and a single byte for the `EXIT` primitive token.  That's actually pretty good math...  7 bytes per used trampoline is not that bad since people probably won't need more than 10 or 20 external words and that's only 70 or 140 bytes.  This isn't great, since we still consume RAM, but it's probably fine.  I still want to get ARF working on the ATtiny85 (512b of RAM), and I guess that probably still works here...
    * Minor tweak: we don't need to compile in `EXIT`; the `DOFFI*` words are just going to call the function and then continue on to the next instruction.
  * This approach means that we'll create a bunch of `DOFFI*` primitives (which we kind of already have) that behave in the same way as `DOCOLON`: `COMPILE,` knows if the XT is an FFI (because it checks the flags in the target definition) and then compiles in `DOFFI0` and the 2/3 byte address of the FFI function in Flash.  `EXECUTE` knows if it has an FFI trampoline definition (again, flags) and basically does the same thing that it does for `DOCOLON`: sets `w` and jumps to something like `DOCOLON_WITH_W` which skips past the point where we read `w` from the IP.
  * And since we have more free opcodes now we can probably code in some of the most frequently used FFI functions (`pinWrite` and stuff) as tokens, perhaps through compiler directives.
  * I wonder if we can find a way to predefine a set of trampolines in Flash instead of in RAM?  *i.e.,* we reserve the last 32 opcodes for precompiled trampolines and then provide a simplified way to build up that flash array.  This table-based method would actually work since it would just be a list of other addresses (which conveniently we already have thanks to the `FFIDEF_*` vars that are being used for the linked list).  This would give users a way to modify their ARF compile to predefine externals in a way that consumes no RAM.  You still need to define the FFIs, but you don't need to reference them at runtime.
  * This feels like a good balance between ROM and RAM: you can access any FFI at runtime if you are willing to consume memory on that (which is probably fine during development) and then you switch to a ROM-based FFI primitive once you know you'll be using an FFI a lot.  This breaks your flash, of course, but your source is unchanged (and we could make the `EXTERNAL:` word just do nothing in the case where you are trying to reference a ROM-based FFI primitive).
  * This makes the ATtiny85 possible again, because we'll just define the primitives that we care about as ROM primitives.
* Switch the "CFA" to opcodes.  The compiler will figure out what kind of word is being compiled and put that opcode into the definition.  This trades compiler expense -- need to interrogate the target word -- for runtime efficiency -- a single jump table for everything.  XTs on the stack might be the only challenge, because those need to include both an opcode and the target.  I suppose we can use the top two bits for the opcode and the remaining 14 bits for the offset.  `COMPILE,` gets more complex, because it then has to convert that XT into a separate 8-bit opcode and 16-bit offset.
  * This change also eliminates the need to differentiate between opcodes and relative offsets, because everything is just an opcode (and then the `DO*` opcodes are followed by the offset).  The only downside is that every call to another word now takes one extra byte of RAM.  The major upside is that now we can create up to 256 opcodes instead of just 128 opcodes; that should enable us to put more stuff into ROM, which might have been necessary anyway...
    * Should probably just make DOCOLON8 and DOCOLON16 and then align PFAs to 16-bits so that DOCOLON8 can span a full -512 bytes.
    * I wonder if the expansion from 128 to 256 primitives means that we should handle FFIs as primitives instead of as trampolines that have to be compiled into the dictionary upon usage?  I can't decide if this is more or less performant than the FFI primitives...
* Fix up all of the types; sometimes we use uint8_t, sometimes we use arfInteger, etc.
* Turn `dictionary` constructor parameter into a generic `vm` parameter.  Put data stack and return stack at the end of the `vm` buffer.  Put TIB at the start of the buffer (before the dictionary, just like MFORTH).  Allow stack sizes and TIB size to be configured in the constructor.  TIB can be zero if you do not need the text interpreter.
* "Fix" stack usage so that we don't have to waste the last (31st, currently) cell on a TOS value that will never be stored there.  Should probably put the stacks at the beginning of the buffer so that we don't have the issue with sometimes reading TOS from beyond the data stack when the stack is in fact empty.  So organization is: data stack, return stack, TIB, hidden defs, dictionary.
* Implement compilation (`:`, `COMPILE,`, `;`, etc.).
* Reorganize/Clean up source files.  Maybe auto-generate opcodes so that we can avoid some of the duplication, for example.
