* Switch the "CFA" to opcodes.  The compiler will figure out what kind of word is being compiled and put that opcode into the definition.  This trades compiler expense -- need to interrogate the target word -- for runtime efficiency -- a single jump table for everything.  XTs on the stack might be the only challenge, because those need to include both an opcode and the target.  I suppose we can use the top two bits for the opcode and the remaining 14 bits for the offset.  `COMPILE,` gets more complex, because it then has to convert that XT into a separate 8-bit opcode and 16-bit offset.
  * This change also eliminates the need to differentiate between opcodes and relative offsets, because everything is just an opcode (and then the `DO*` opcodes are followed by the offset).  The only downside is that every call to another word now takes one extra byte of RAM.  The major upside is that now we can create up to 256 opcodes instead of just 128 opcodes; that should enable us to put more stuff into ROM, which might have been necessary anyway...
    * Should probably just make DOCOLON8 and DOCOLON16 and then align PFAs to 16-bits so that DOCOLON8 can span a full -512 bytes.
    * I wonder if the expansion from 128 to 256 primitives means that we should handle FFIs as primitives instead of as trampolines that have to be compiled into the dictionary upon usage?  I can't decide if this is more or less performant than the FFI primitives...
  * As part of this work we should create a CFA for ROM-based definitions.  On the AVR this switches `*ip` dereferencing to go through PROGMEM (and so we need an extra `if` statement, but the benefit is that we can easily produce ROM-based definitions, which in some cases will be smaller than compiled C code).
* Fix up all of the types; sometimes we use uint8_t, sometimes we use arfInteger, etc.
* Turn `dictionary` constructor parameter into a generic `vm` parameter.  Put data stack and return stack at the end of the `vm` buffer.  Put TIB at the start of the buffer (before the dictionary, just like MFORTH).  Allow stack sizes and TIB size to be configured in the constructor.  TIB can be zero if you do not need the text interpreter.
* "Fix" stack usage so that we don't have to waste the last (31st, currently) cell on a TOS value that will never be stored there.  Should probably put the stacks at the beginning of the buffer so that we don't have the issue with sometimes reading TOS from beyond the data stack when the stack is in fact empty.  So organization is: data stack, return stack, TIB, hidden defs, dictionary.
* Move hidden defs into Flash and add a local variable to the inner interpreter that that switches between RAM and Flash threading (we'll need a dedicated CFA for this).
* Implement compilation (`:`, `COMPILE,`, `;`, etc.).
* Reorganize/Clean up source files.  Maybe auto-generate opcodes so that we can avoid some of the duplication, for example.
