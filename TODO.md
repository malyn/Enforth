* Remove the need for `PIQDO`, `PILOOP`, and `PIPLUSLOOP` by modifying `DUMP` to use `BEGIN` and `REPEAT` instead of loops.
  * This is low-hanging fruit and needs to be done anyway.
* We're out of tokens and the token multiplier has gotten out of control: x12 resulting in 871 bytes of padding (50% of the 1,745 of non-padding bytes!).  There are still a handful of additional words that need to be defined (maybe a dozen?) and ideally we would leave space for other things.
  * Doing something smart about padding would be helpful as well, although for now we should focus on making more tokens available.
  * Some words can probably be eliminated and/or folded in to other words (`C+!` wasn't being used, for example).
  * Getting rid of the need to dedicated tokens for the `P*` CFAs would be get us 16 more bytes (by just making a separate, definition type-based jump table in `(EXECUTE)`).
    * This could be subtle though, because `(EXECUTE)` would no longer take a token and a PFA, but would in some cases take an XT ($8000 | offset) and PFA and then the XT would be dereferenced in order to get the definition type.
    * Note that only `(EXECUTE)` needs this special functionality, because we would still retain the non-`P*` CFA tokens since those are what gets compiled into other definitions.
    * I wonder if maybe `(EXECUTE)` should just be given compilation tokens (and so we rename `>[TOKEN]` into `>TOKEN`) and then `(EXECUTE)` masks/shifts the compilation token into an offset into its local jumptable of `P*` definitions.
      * Actually, this is even easier than I thought!  We now set `W` in a single place *before* `DISPATCH_TOKEN`, so `(EXECUTE)` just needs to set W (which it already does) and then turn the def type into a CFA (which is just an OR operation).  At that point the `xt` param is either a token or a definition type, and the latter is indicated by a $4000 | offset (just so that it is clear that we don't have an $8000-style XT).
  * `I` could compile `R@` instead of providing its own token.  Same thing with `(DO)` and `2>R`
  * `(LOOP)` could maybe always be `(+LOOP)` with a `:charlit 1` in front?
  * Rewriting `DUMP` to use `BEGIN/REPEAT` instead of `DO/LOOP` eliminates `PIQDO`, `PILOOP`, and `PIPLUSLOOP`.
  * `TICKNAMES` could just put a reference to names in the `vm` structure so that it could be accessed with `VM`.
  * `DOCONSTANT` and `DOVARIABLE` could have their CFA compiled into each definition: for `DOCONSTANT` it is `"LIT $1234 @"` where `LIT $1234` is `LIT` and the `HERE` address when the definition was created; `DOVARIABLE` is just `"LIT $1234"`.  This would free up four tokens, although at the cost of RAM (which doesn't feel like a good trade).
  * The last resort would be to stop using tokens for ROM definitions and instead use a two-byte $8000-style XT.  I don't love that though, especially because we now have to differentiate between ROM XTs and user XTs.
    * On the other hand, this could cut the size of our jump table in half and also completely eliminate the need for padding.
    * The ROM definitions might not be used as much (at runtime) as the code primitives, so the number of times that a two-byte XT has to be compiled could be minimal...  We don't care about interpretation performance, so using longer XTs there is fine (although DefGen would have to get a lot smarter and do a two-pass compile, among other things).
      * Yeah, it actually looks like the runtime words (*i.e.,* not those that are primarily used by the text interpreter) are almost all in code primitives already, so moving everything else to two-byte XTs isn't likely to increase the size of user definitions all that much.
      * Some of the common math words (`*`, `/`, `MOD`, etc.) are in definitions though and should maybe be moved into code.
    * Huh, so calling other user definitions takes three bytes (token + PFA).  If we used a flag model (8000 for user defs, 4000 for ROM defs), then calling user definitions would only take two bytes, ROM definitions (which almost never get called at runtime anyway) would take two bytes, and code primitives would still only be one byte.
      * We still need the CFA token though.  I suppose that we could move that back into the "real" CFA slot and have `EXECUTE` and the address interpreter start from that byte, setting `W` to the byte after the CFA.  `DOCOLON` is then just a normal token that stashes things on the return stack and continues to the next token (which is the PFA).
        * I wonder if we even need to set `W` at that point?  Does anyone need `W` at the point where the IP auto-advances to the PFA?  `DOCONSTANT` is then just `LIT`, for example.  `DOVARIABLE` just pushes the current IP onto the stack and then jumps to `EXIT`.
          * Yes, you do need `W` because you have to push the previous IP onto the return stack before you start executing the new word.  So `DOCOLON` has to exist as a thing that does that push *if we set the IP to the CFA*.  If we don't set the IP to the CFA, but instead IP is before the thing that jumped to the token, then the CFA could do a push (or not, in the case of `DOCONSTANT` and `DOVARIABLE`) before setting IP to the PFA.  And so we need to set `W` in that case.
      * We only have 88 code primitives right now, so we could definitely access those with 7 bits and then use the 8th bit as a flag indicating that a two-byte XT is in use.
      * Our ROM definition block is under 2KB right now (assuming that we eliminated the padding), which means that we can easily use a $4000-prefixed offset (8KB) for those definitions.  We're already using an $8000-prefixed offset for XTs due to Harvard architectures, so there is no change there.
        * We could actually use an $800-prefixed XT for ROM definitions and then uses bits 12-14 for specifying the FFI arity of FFI trampolines.  FFI trampolines would then just be a raw function pointer compiled in to the dictionary.
      * Note that this approach ties a compiled program (in EEPROM, for example) much more closely to the Enforth build -- we can't change the length of a ROM definition, for example.  That feels like a minor issue anyway; I doubt that most people are going to make changes to Enforth; most (all?) extensibility points will be through FFI definitions.
      * **We thought about this before and threw it out.**  We need to figure out why.
* Start creating the `enforth_*_extern.h` files for various Arduino libs in order to validate the FFI code, workflow, etc.
  * Consider creating a namespace enum for externs so that we can rewrite the FFIDef addresses after a load.  The trampoline would then contain the 16-bit id of the extern (10 bits for namespace, 6 bits for function).
* PARSE-WORD needs to treat all control characters as space if given a space as the delimiter.
* Improve the stack checking code.
  * First, the code is probably too aggressive and may not let us use the last stack item.
  * Second, we have the macro scattered everywhere, but it would be better if the stack sizes were declared in a separate table, organized by token, and then checked in a single place right before DISPATCH\_TOKEN.  Similar to the rest of these tables, the source auto-generator will make it easier to build this table.
  * We should also check the return stack.
* Consider using the pgmspace typedefs (prog\_int8\_t, etc.) if that would make it easier to catch situations where we forgot to use the pgm\_\* accessors.
* Consider creating EnforthDuino.cpp/.h wrappers to make it easier to interact with Enforth in the Arduino environment.
* Add comments to all of the `.edn` files.
* Modify DefGen so that it puts the 0xFF into the names table as soon as the last named primitive is seen (instead of adding in all of those wasted 0x00 bytes).
* Do something about absolute RAM addresses on the stack, in variables, etc.  These prevent the VM from being saved to/from storage (such as EEPROM).
  * We can't relativize everything on save, because we don't always know what we are looking at -- how do we know that a dictionary variable contains a RAM address?  We could probably relativize all addresses in the VM though and then `@`, `!`, etc. would do the adjustment as necessary (and could offer bounds-checking).  All of these addresses are VM-relative and that VM base address will probably end up being stored in a constant register pair.  Access to memory-mapped CPU resources gets messy (this is mostly an ARM problem), although we could offer special fetch and store operations for those.  Similarly, FFI interop involving addresses is now a problem because we need to convert those back and forth.
  * Note that the VM itself has quite a few absolute addresses (DP, HERE, SOURCE, etc.) and we'll need to deal with those on load/save.  Most of these have to do with the text interpreter though and we could easily just say that persistence resets the state of the text interpreter and can only be performed when *not* in compilation mode.  That would leave a very small number of pointers in the VM and those could just be serialized as part of persisting the dictionary.
* Move `dp` and `latest` into the dictionary so that they load/save with the dictionary.
* Add a single default task and move the stacks and BASE into that memory area.  No `PAUSE` yet.
  * Tasks are 32 return stack cells (64/128 bytes), 16 data stack cells (32/64 bytes), 16 user cells (32/64 bytes) for a total of 128/256 bytes per task.
    * Note that tasks go into the dictionary and not at the end!  This allows dictionaries to be resized or only partially copied to storage.
    * Need one task cell to act as a link to the previously-created task as well as a global that points to the newest task (similar to the dictionary itself).
* Forth200x updates (mostly just `TIB` and `#TIB`?, although numeric prefixes look very useful).
* Add `PAUSE`, which spills the registers to global variables in `vm` and then returns from `go()` similar to what we did in Ficl.
* Add dumb exceptions that just restart the VM?
* Consider optimizing the size of `DOCOLON` references by creating "bank-switched" versions of this token.  This would reduce the number of times that calling a definition needs three bytes instead of just two bytes (the primary downside to dictionary-relative instead of IP-relative compilation offsets).
  * You could call `DOCOLON0` for offsets 0-511 in the dictionary, `DOCOLON1` for 512-1023, etc.  Eight of these would allow us to span 4KB of dictionary, at which point we would just fall back to absolute references.  Most (?) dictionaries probably won't be greater than 4KB anyway, and at that point you probably have plenty of RAM to blow on three-byte references.
  * `ALIGN` would actually be needed now in order to make each bank span as many bytes as possible.
  * Remember that compiled XTs can never be smaller than 16-bits anyway, so the goal here is to try and keep those XTs at 16 bits most of the time if possible.
* Consider adding `PAD`, perhaps with a configurable size.  Do not use `PAD` in the kernel though so that we can avoid making it a requirement.
* We may not need to blow 16 tokens on the `PDO*` primitives; instead we can just create a dedicated jump table in `EXECUTE` for those tokens.  `EXECUTE` is almost only ever used when we are doing text interpretation, so spilling and filling registers here should be fine.
  * The only thing that this does is save us token space, it still uses the same amount of ROM.  This is only valuable/necessary if we are running low on tokens.
* Since we have more free tokens now we can probably code in some of the most frequently used FFI functions (`pinWrite` and stuff) as tokens, perhaps through compiler directives.
  * I wonder if we can find a way to predefine a set of trampolines in Flash instead of in RAM?  *i.e.,* we reserve the last 32 tokens for precompiled trampolines and then provide a simplified way to build up that flash array.  This table-based method would actually work since it would just be a list of other addresses (which conveniently we already have thanks to the `FFIDEF_*` vars that are being used for the linked list).  This would give users a way to modify their enforth compile to predefine externals in a way that consumes no RAM.  You still need to define the FFIs, but you don't need to reference them at runtime.
  * This feels like a good balance between ROM and RAM: you can access any FFI at runtime if you are willing to consume memory on that (which is probably fine during development) and then you switch to a ROM-based FFI primitive once you know you'll be using an FFI a lot.  This breaks your flash, of course, but your source is unchanged (and we could make the `EXTERNAL:` word just do nothing in the case where you are trying to reference a ROM-based FFI primitive).
  * This makes the ATtiny85 possible again, because we'll just define the primitives that we care about as ROM primitives.
* Consider different multipliers for the ROM definitions.
  * Maybe we should multiply the token by a prime (3?) instead of 4 so that we can pack these in more/perfectly tightly?  Something along the lines of a Golomb Ruler?  Multiplication on the AVR takes two cycles, just like two left shifts (for x4), so we might as well multiply if it gets us better packing.
